% Final Program For Transition Diagram
% Automatically Generated By ALM Translator 0.1.0.


sorts

#booleans = {true, false}.

#integers = {}.

#deliver = {}.

#lose = {}.

#get_13_5_1_1 = {e1, e5}.

#get_13_5_1 = {e5, e1}.

#take = {}.

#steal_10_5_1 = {e4}.

#steal_10_5 = {e4}.

#obtain = {e1, e4, e5}.

#receive = {e5, e4, e1}.

#transfer = {e1, e4, e5}.

#slide_11_2_1 = {}.

#slide_11_2 = {e2}.

#go_to = {e2}.

#carry = {}.

#leave = {}.

#run_51_3_2_2_1 = {}.

#run_51_3_2_2 = {}.

#run_51_3_2_1 = {e3, e6}.

#run_51_3_2 = {e6, e3}.

#walk = {e3, e6}.

#locomotion = {e2, e6, e3}.

#move = {e2, e3, e6}.

#actions = {e2, e6, e5, e4, e3, e1}.

#activity = {}.

#event = {e2, e1, e3, e4, e5, e6}.

#office = {r6}.

#garden = {r9}.

#inanimate_object = {}.

#john = {r3}.

#football = {r8}.

#mary = {r1}.

#apple = {r7}.

#daniel = {r5}.

#milk = {r2}.

#living_entity = {r1, r2, r3, r5, r7, r8}.

#physical_object = {r8, r7, r5, r3, r2, r1}.

#tangible_entity = {r1, r2, r3, r5, r7, r8}.

#bedroom = {r4}.

#place = {}.

#spatial_entity = {r4, r6, r9, r8, r7, r5, r3, r2, r1}.

#entity = {r9, r6, r4, r1, r2, r3, r5, r7, r8}.

#thing = {r4, r6, r9, r8, r7, r5, r3, r2, r1, e2, e6, e5, e4, e3, e1}.

#universe = {r9, r6, r4, r1, r2, r3, r5, r7, r8, e2, e1, e3, e4, e5, e6} + #booleans.

#timeStep = {0, 1, 2, 3, 4, 5, 6}.

#sort_hierarchy_nodes_ = {universe, timeStep, actions, booleans, integers, comparable_integers_subsort, thing, entity, spatial_entity, place, tangible_entity, physical_object, inanimate_object, living_entity, event, activity, transfer, deliver, lose, receive, obtain, take, get_13_5_1, get_13_5_1_1, mary, milk, john, bedroom, daniel, office, apple, football, garden, move, locomotion, carry, go_to, leave, walk, run_51_3_2, run_51_3_2_2, run_51_3_2_2_1, steal_10_5, steal_10_5_1, run_51_3_2_1, slide_11_2, slide_11_2_1}.

#fluent_functions = is_at(#entity, #spatial_entity) + is_behind(#spatial_entity, #spatial_entity) + is_between(#spatial_entity, #spatial_entity) + is_outside(#spatial_entity, #spatial_entity) + is_known(#entity) + is_above(#spatial_entity, #spatial_entity) + is_along(#spatial_entity, #spatial_entity) + is_held(#tangible_entity) + contained_in(#tangible_entity, #tangible_entity) + location(#tangible_entity, #spatial_entity) + is_touching(#tangible_entity, #tangible_entity) + is_accessible(#entity) + shut_out_of(#tangible_entity, #tangible_entity) + is_over(#spatial_entity, #spatial_entity) + is_near(#spatial_entity, #spatial_entity) + is_inside(#spatial_entity, #spatial_entity) + is_closed(#spatial_entity) + is_opposite(#spatial_entity, #spatial_entity) + abuts(#spatial_entity, #spatial_entity) + content(#tangible_entity, #entity) + is_restrained(#tangible_entity) + is_in_front_of(#spatial_entity, #spatial_entity) + occurs(#actions) + is_on(#spatial_entity, #spatial_entity) + blocked_with(#spatial_entity, #entity) + has_part(#entity, #entity) + possesses(#entity, #entity) + is_under(#spatial_entity, #spatial_entity) + confined_to(#tangible_entity, #tangible_entity) + encloses(#spatial_entity, #spatial_entity) + is_blocked(#spatial_entity) + is_confined(#tangible_entity) + held_by(#tangible_entity, #tangible_entity) + is_below(#spatial_entity, #spatial_entity) + is_contained(#tangible_entity) + accessible_to(#entity, #thing) + is_beside(#spatial_entity, #spatial_entity) + known_to(#entity, #tangible_entity).



predicates

% Special Function [instance]
instance(#universe, #sort_hierarchy_nodes_).

% Domain Function [dom_instance].
dom_instance(#universe, #sort_hierarchy_nodes_).

% Fluent Function [is_outside]
is_outside(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_outside].
dom_is_outside(#spatial_entity, #spatial_entity, #timeStep).

% Special Function [link]
link(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% Domain Function [dom_link].
dom_link(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% Attribute Function [object] for sort [event].
event_object(#event, #entity).

% Domain Function [dom_event_object] for attribute function [object] of sort [event].
dom_event_object(#event, #entity).

% Special Function [has_child]
has_child(#sort_hierarchy_nodes_).

% Domain Function [dom_has_child].
dom_has_child(#sort_hierarchy_nodes_).

% Fluent Function [contained_in]
contained_in(#tangible_entity, #tangible_entity, #timeStep).

% Domain Function [dom_contained_in].
dom_contained_in(#tangible_entity, #tangible_entity, #timeStep).

% Static Function [defined_away_from]
defined_away_from(#event).

% Domain Function [dom_defined_away_from].
dom_defined_away_from(#event).

% Attribute Function [vn_cause] for sort [actions].
actions_vn_cause(#actions, #thing).

% Domain Function [dom_actions_vn_cause] for attribute function [vn_cause] of sort [actions].
dom_actions_vn_cause(#actions, #thing).

% Fluent Function [is_near]
is_near(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_near].
dom_is_near(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_experiencer] for sort [actions].
actions_vn_experiencer(#actions, #entity).

% Domain Function [dom_actions_vn_experiencer] for attribute function [vn_experiencer] of sort [actions].
dom_actions_vn_experiencer(#actions, #entity).

% Fluent Function [is_opposite]
is_opposite(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_opposite].
dom_is_opposite(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_pivot] for sort [actions].
actions_vn_pivot(#actions, #thing).

% Domain Function [dom_actions_vn_pivot] for attribute function [vn_pivot] of sort [actions].
dom_actions_vn_pivot(#actions, #thing).

% Attribute Function [site] for sort [event].
event_site(#event, #spatial_entity).

% Domain Function [dom_event_site] for attribute function [site] of sort [event].
dom_event_site(#event, #spatial_entity).

% Special Function [occurs]
occurs(#actions, #timeStep).

% Domain Function [dom_occurs].
dom_occurs(#actions, #timeStep).

% Fluent Function [is_on]
is_on(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_on].
dom_is_on(#spatial_entity, #spatial_entity, #timeStep).

% Fluent Function [is_under]
is_under(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_under].
dom_is_under(#spatial_entity, #spatial_entity, #timeStep).

% Fluent Function [is_confined]
is_confined(#tangible_entity, #timeStep).

% Domain Function [dom_is_confined].
dom_is_confined(#tangible_entity, #timeStep).

% Attribute Function [vn_location] for sort [actions].
actions_vn_location(#actions, #spatial_entity).

% Domain Function [dom_actions_vn_location] for attribute function [vn_location] of sort [actions].
dom_actions_vn_location(#actions, #spatial_entity).

% Attribute Function [agent] for sort [event].
event_agent(#event, #entity).

% Domain Function [dom_event_agent] for attribute function [agent] of sort [event].
dom_event_agent(#event, #entity).

% Attribute Function [vn_beneficiary] for sort [actions].
actions_vn_beneficiary(#actions, #living_entity).

% Domain Function [dom_actions_vn_beneficiary] for attribute function [vn_beneficiary] of sort [actions].
dom_actions_vn_beneficiary(#actions, #living_entity).

% Attribute Function [vn_trajectory] for sort [actions].
actions_vn_trajectory(#actions, #thing).

% Domain Function [dom_actions_vn_trajectory] for attribute function [vn_trajectory] of sort [actions].
dom_actions_vn_trajectory(#actions, #thing).

% Attribute Function [toward] for sort [event].
event_toward(#event, #spatial_entity).

% Domain Function [dom_event_toward] for attribute function [toward] of sort [event].
dom_event_toward(#event, #spatial_entity).

% Static Function [defined_toward]
defined_toward(#event).

% Domain Function [dom_defined_toward].
dom_defined_toward(#event).

% Attribute Function [vn_extent] for sort [actions].
actions_vn_extent(#actions, #entity).

% Domain Function [dom_actions_vn_extent] for attribute function [vn_extent] of sort [actions].
dom_actions_vn_extent(#actions, #entity).

% Attribute Function [vn_value] for sort [actions].
actions_vn_value(#actions, #thing).

% Domain Function [dom_actions_vn_value] for attribute function [vn_value] of sort [actions].
dom_actions_vn_value(#actions, #thing).

% Attribute Function [vn_initial_location] for sort [actions].
actions_vn_initial_location(#actions, #spatial_entity).

% Domain Function [dom_actions_vn_initial_location] for attribute function [vn_initial_location] of sort [actions].
dom_actions_vn_initial_location(#actions, #spatial_entity).

% Fluent Function [is_between]
is_between(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_between].
dom_is_between(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_coagent] for sort [actions].
actions_vn_coagent(#actions, #entity).

% Domain Function [dom_actions_vn_coagent] for attribute function [vn_coagent] of sort [actions].
dom_actions_vn_coagent(#actions, #entity).

% Attribute Function [vn_source] for sort [actions].
actions_vn_source(#actions, #spatial_entity).

% Domain Function [dom_actions_vn_source] for attribute function [vn_source] of sort [actions].
dom_actions_vn_source(#actions, #spatial_entity).

% Fluent Function [is_held]
is_held(#tangible_entity, #timeStep).

% Domain Function [dom_is_held].
dom_is_held(#tangible_entity, #timeStep).

% Fluent Function [location]
location(#tangible_entity, #spatial_entity, #timeStep).

% Domain Function [dom_location].
dom_location(#tangible_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_result] for sort [actions].
actions_vn_result(#actions, #thing).

% Domain Function [dom_actions_vn_result] for attribute function [vn_result] of sort [actions].
dom_actions_vn_result(#actions, #thing).

% Attribute Function [vn_theme] for sort [actions].
actions_vn_theme(#actions, #entity).

% Domain Function [dom_actions_vn_theme] for attribute function [vn_theme] of sort [actions].
dom_actions_vn_theme(#actions, #entity).

% Attribute Function [vn_attribute] for sort [actions].
actions_vn_attribute(#actions, #thing).

% Domain Function [dom_actions_vn_attribute] for attribute function [vn_attribute] of sort [actions].
dom_actions_vn_attribute(#actions, #thing).

% Attribute Function [vn_initial_state] for sort [actions].
actions_vn_initial_state(#actions, #entity).

% Domain Function [dom_actions_vn_initial_state] for attribute function [vn_initial_state] of sort [actions].
dom_actions_vn_initial_state(#actions, #entity).

% Fluent Function [abuts]
abuts(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_abuts].
dom_abuts(#spatial_entity, #spatial_entity, #timeStep).

% Static Function [defined_origin]
defined_origin(#event).

% Domain Function [dom_defined_origin].
dom_defined_origin(#event).

% Fluent Function [blocked_with]
blocked_with(#spatial_entity, #entity, #timeStep).

% Domain Function [dom_blocked_with].
dom_blocked_with(#spatial_entity, #entity, #timeStep).

% Static Function [defined_object]
defined_object(#event).

% Domain Function [dom_defined_object].
dom_defined_object(#event).

% Static Function [defined_result]
defined_result(#event).

% Domain Function [dom_defined_result].
dom_defined_result(#event).

% Special Function [has_parent]
has_parent(#sort_hierarchy_nodes_).

% Domain Function [dom_has_parent].
dom_has_parent(#sort_hierarchy_nodes_).

% Attribute Function [vn_recipient] for sort [actions].
actions_vn_recipient(#actions, #entity).

% Domain Function [dom_actions_vn_recipient] for attribute function [vn_recipient] of sort [actions].
dom_actions_vn_recipient(#actions, #entity).

% Attribute Function [vn_material] for sort [actions].
actions_vn_material(#actions, #entity).

% Domain Function [dom_actions_vn_material] for attribute function [vn_material] of sort [actions].
dom_actions_vn_material(#actions, #entity).

% Fluent Function [held_by]
held_by(#tangible_entity, #tangible_entity, #timeStep).

% Domain Function [dom_held_by].
dom_held_by(#tangible_entity, #tangible_entity, #timeStep).

% Attribute Function [vn_goal] for sort [actions].
actions_vn_goal(#actions, #entity).

% Domain Function [dom_actions_vn_goal] for attribute function [vn_goal] of sort [actions].
dom_actions_vn_goal(#actions, #entity).

% Attribute Function [vn_reflexive] for sort [actions].
actions_vn_reflexive(#actions, #thing).

% Domain Function [dom_actions_vn_reflexive] for attribute function [vn_reflexive] of sort [actions].
dom_actions_vn_reflexive(#actions, #thing).

% Attribute Function [vn_agent] for sort [actions].
actions_vn_agent(#actions, #entity).

% Domain Function [dom_actions_vn_agent] for attribute function [vn_agent] of sort [actions].
dom_actions_vn_agent(#actions, #entity).

% Fluent Function [is_contained]
is_contained(#tangible_entity, #timeStep).

% Domain Function [dom_is_contained].
dom_is_contained(#tangible_entity, #timeStep).

% Fluent Function [is_beside]
is_beside(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_beside].
dom_is_beside(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_topic] for sort [actions].
actions_vn_topic(#actions, #thing).

% Domain Function [dom_actions_vn_topic] for attribute function [vn_topic] of sort [actions].
dom_actions_vn_topic(#actions, #thing).

% Fluent Function [known_to]
known_to(#entity, #tangible_entity, #timeStep).

% Domain Function [dom_known_to].
dom_known_to(#entity, #tangible_entity, #timeStep).

% Attribute Function [beneficiary] for sort [event].
event_beneficiary(#event, #living_entity).

% Domain Function [dom_event_beneficiary] for attribute function [beneficiary] of sort [event].
dom_event_beneficiary(#event, #living_entity).

% Special Function [sink]
sink(#sort_hierarchy_nodes_).

% Domain Function [dom_sink].
dom_sink(#sort_hierarchy_nodes_).

% Fluent Function [is_at]
is_at(#entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_at].
dom_is_at(#entity, #spatial_entity, #timeStep).

% Attribute Function [instrument] for sort [event].
event_instrument(#event, #entity).

% Domain Function [dom_event_instrument] for attribute function [instrument] of sort [event].
dom_event_instrument(#event, #entity).

% Static Function [defined_agent]
defined_agent(#event).

% Domain Function [dom_defined_agent].
dom_defined_agent(#event).

% Fluent Function [is_above]
is_above(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_above].
dom_is_above(#spatial_entity, #spatial_entity, #timeStep).

% Fluent Function [is_along]
is_along(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_along].
dom_is_along(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_cotheme] for sort [actions].
actions_vn_cotheme(#actions, #entity).

% Domain Function [dom_actions_vn_cotheme] for attribute function [vn_cotheme] of sort [actions].
dom_actions_vn_cotheme(#actions, #entity).

% Static Function [defined_destination]
defined_destination(#event).

% Domain Function [dom_defined_destination].
dom_defined_destination(#event).

% Special Function [is_a]
is_a(#universe, #sort_hierarchy_nodes_).

% Domain Function [dom_is_a].
dom_is_a(#universe, #sort_hierarchy_nodes_).

% Fluent Function [is_over]
is_over(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_over].
dom_is_over(#spatial_entity, #spatial_entity, #timeStep).

% Static Function [defined_recipient]
defined_recipient(#event).

% Domain Function [dom_defined_recipient].
dom_defined_recipient(#event).

% Attribute Function [vn_asset] for sort [actions].
actions_vn_asset(#actions, #thing).

% Domain Function [dom_actions_vn_asset] for attribute function [vn_asset] of sort [actions].
dom_actions_vn_asset(#actions, #thing).

% Fluent Function [is_inside]
is_inside(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_inside].
dom_is_inside(#spatial_entity, #spatial_entity, #timeStep).

% Fluent Function [is_closed]
is_closed(#spatial_entity, #timeStep).

% Domain Function [dom_is_closed].
dom_is_closed(#spatial_entity, #timeStep).

% Fluent Function [content]
content(#tangible_entity, #entity, #timeStep).

% Domain Function [dom_content].
dom_content(#tangible_entity, #entity, #timeStep).

% Static Function [defined_experiencer]
defined_experiencer(#event).

% Domain Function [dom_defined_experiencer].
dom_defined_experiencer(#event).

% Fluent Function [is_restrained]
is_restrained(#tangible_entity, #timeStep).

% Domain Function [dom_is_restrained].
dom_is_restrained(#tangible_entity, #timeStep).

% Fluent Function [is_in_front_of]
is_in_front_of(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_in_front_of].
dom_is_in_front_of(#spatial_entity, #spatial_entity, #timeStep).

% Static Function [defined_path]
defined_path(#event).

% Domain Function [dom_defined_path].
dom_defined_path(#event).

% Fluent Function [has_part]
has_part(#entity, #entity, #timeStep).

% Domain Function [dom_has_part].
dom_has_part(#entity, #entity, #timeStep).

% Attribute Function [vn_time] for sort [actions].
actions_vn_time(#actions, #thing).

% Domain Function [dom_actions_vn_time] for attribute function [vn_time] of sort [actions].
dom_actions_vn_time(#actions, #thing).

% Fluent Function [possesses]
possesses(#entity, #entity, #timeStep).

% Domain Function [dom_possesses].
dom_possesses(#entity, #entity, #timeStep).

% Attribute Function [base] for sort [event].
event_base(#event, #thing).

% Domain Function [dom_event_base] for attribute function [base] of sort [event].
dom_event_base(#event, #thing).

% Attribute Function [vn_instrument] for sort [actions].
actions_vn_instrument(#actions, #entity).

% Domain Function [dom_actions_vn_instrument] for attribute function [vn_instrument] of sort [actions].
dom_actions_vn_instrument(#actions, #entity).

% Fluent Function [encloses]
encloses(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_encloses].
dom_encloses(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [vn_stimulus] for sort [actions].
actions_vn_stimulus(#actions, #thing).

% Domain Function [dom_actions_vn_stimulus] for attribute function [vn_stimulus] of sort [actions].
dom_actions_vn_stimulus(#actions, #thing).

% Attribute Function [vn_predicate] for sort [actions].
actions_vn_predicate(#actions, #thing).

% Domain Function [dom_actions_vn_predicate] for attribute function [vn_predicate] of sort [actions].
dom_actions_vn_predicate(#actions, #thing).

% Attribute Function [path] for sort [event].
event_path(#event, #spatial_entity).

% Domain Function [dom_event_path] for attribute function [path] of sort [event].
dom_event_path(#event, #spatial_entity).

% Attribute Function [experiencer] for sort [event].
event_experiencer(#event, #entity).

% Domain Function [dom_event_experiencer] for attribute function [experiencer] of sort [event].
dom_event_experiencer(#event, #entity).

% Static Function [defined_beneficiary]
defined_beneficiary(#event).

% Domain Function [dom_defined_beneficiary].
dom_defined_beneficiary(#event).

% Attribute Function [donor] for sort [event].
event_donor(#event, #entity).

% Domain Function [dom_event_donor] for attribute function [donor] of sort [event].
dom_event_donor(#event, #entity).

% Fluent Function [accessible_to]
accessible_to(#entity, #thing, #timeStep).

% Domain Function [dom_accessible_to].
dom_accessible_to(#entity, #thing, #timeStep).

% Attribute Function [result] for sort [event].
event_result(#event, #entity).

% Domain Function [dom_event_result] for attribute function [result] of sort [event].
dom_event_result(#event, #entity).

% Attribute Function [vn_causer] for sort [actions].
actions_vn_causer(#actions, #thing).

% Domain Function [dom_actions_vn_causer] for attribute function [vn_causer] of sort [actions].
dom_actions_vn_causer(#actions, #thing).

% Fluent Function [is_behind]
is_behind(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_behind].
dom_is_behind(#spatial_entity, #spatial_entity, #timeStep).

% Attribute Function [recipient] for sort [event].
event_recipient(#event, #entity).

% Domain Function [dom_event_recipient] for attribute function [recipient] of sort [event].
dom_event_recipient(#event, #entity).

% Special Function [subsort]
subsort(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% Domain Function [dom_subsort].
dom_subsort(#sort_hierarchy_nodes_, #sort_hierarchy_nodes_).

% Attribute Function [vn_actor] for sort [actions].
actions_vn_actor(#actions, #entity).

% Domain Function [dom_actions_vn_actor] for attribute function [vn_actor] of sort [actions].
dom_actions_vn_actor(#actions, #entity).

% Fluent Function [is_known]
is_known(#entity, #timeStep).

% Domain Function [dom_is_known].
dom_is_known(#entity, #timeStep).

% Attribute Function [away_from] for sort [event].
event_away_from(#event, #spatial_entity).

% Domain Function [dom_event_away_from] for attribute function [away_from] of sort [event].
dom_event_away_from(#event, #spatial_entity).

% Attribute Function [origin] for sort [event].
event_origin(#event, #spatial_entity).

% Domain Function [dom_event_origin] for attribute function [origin] of sort [event].
dom_event_origin(#event, #spatial_entity).

% Fluent Function [is_touching]
is_touching(#tangible_entity, #tangible_entity, #timeStep).

% Domain Function [dom_is_touching].
dom_is_touching(#tangible_entity, #tangible_entity, #timeStep).

% Fluent Function [is_accessible]
is_accessible(#entity, #timeStep).

% Domain Function [dom_is_accessible].
dom_is_accessible(#entity, #timeStep).

% Attribute Function [vn_destination] for sort [actions].
actions_vn_destination(#actions, #spatial_entity).

% Domain Function [dom_actions_vn_destination] for attribute function [vn_destination] of sort [actions].
dom_actions_vn_destination(#actions, #spatial_entity).

% Fluent Function [shut_out_of]
shut_out_of(#tangible_entity, #tangible_entity, #timeStep).

% Domain Function [dom_shut_out_of].
dom_shut_out_of(#tangible_entity, #tangible_entity, #timeStep).

% Static Function [defined_donor]
defined_donor(#event).

% Domain Function [dom_defined_donor].
dom_defined_donor(#event).

% Attribute Function [vn_product] for sort [actions].
actions_vn_product(#actions, #entity).

% Domain Function [dom_actions_vn_product] for attribute function [vn_product] of sort [actions].
dom_actions_vn_product(#actions, #entity).

% Attribute Function [vn_patient] for sort [actions].
actions_vn_patient(#actions, #entity).

% Domain Function [dom_actions_vn_patient] for attribute function [vn_patient] of sort [actions].
dom_actions_vn_patient(#actions, #entity).

% Static Function [defined_raw_material]
defined_raw_material(#event).

% Domain Function [dom_defined_raw_material].
dom_defined_raw_material(#event).

% Attribute Function [destination] for sort [event].
event_destination(#event, #spatial_entity).

% Domain Function [dom_event_destination] for attribute function [destination] of sort [event].
dom_event_destination(#event, #spatial_entity).

% Attribute Function [vn_copatient] for sort [actions].
actions_vn_copatient(#actions, #entity).

% Domain Function [dom_actions_vn_copatient] for attribute function [vn_copatient] of sort [actions].
dom_actions_vn_copatient(#actions, #entity).

% Special Function [source]
source(#sort_hierarchy_nodes_).

% Domain Function [dom_source].
dom_source(#sort_hierarchy_nodes_).

% Fluent Function [confined_to]
confined_to(#tangible_entity, #tangible_entity, #timeStep).

% Domain Function [dom_confined_to].
dom_confined_to(#tangible_entity, #tangible_entity, #timeStep).

% Fluent Function [is_blocked]
is_blocked(#spatial_entity, #timeStep).

% Domain Function [dom_is_blocked].
dom_is_blocked(#spatial_entity, #timeStep).

% Static Function [defined_base]
defined_base(#event).

% Domain Function [dom_defined_base].
dom_defined_base(#event).

% Static Function [defined_site]
defined_site(#event).

% Domain Function [dom_defined_site].
dom_defined_site(#event).

% Attribute Function [raw_material] for sort [event].
event_raw_material(#event, #tangible_entity).

% Domain Function [dom_event_raw_material] for attribute function [raw_material] of sort [event].
dom_event_raw_material(#event, #tangible_entity).

% Fluent Function [is_below]
is_below(#spatial_entity, #spatial_entity, #timeStep).

% Domain Function [dom_is_below].
dom_is_below(#spatial_entity, #spatial_entity, #timeStep).

% Static Function [defined_instrument]
defined_instrument(#event).

% Domain Function [dom_defined_instrument].
dom_defined_instrument(#event).

observed(#fluent_functions, #universe, #timeStep).

happened(#actions, #timeStep).



rules

%---------------------
%-- Section: link
%---------------------

% [integers] is a child sort of [universe]
link(integers, universe).

% [actions] is a child sort of [universe]
link(actions, universe).

% [transfer] is a child sort of [actions]
link(transfer, actions).

% [deliver] is a child sort of [transfer]
link(deliver, transfer).

% [lose] is a child sort of [transfer]
link(lose, transfer).

% [receive] is a child sort of [transfer]
link(receive, transfer).

% [obtain] is a child sort of [receive]
link(obtain, receive).

% [get_13_5_1] is a child sort of [obtain]
link(get_13_5_1, obtain).

% [get_13_5_1_1] is a child sort of [get_13_5_1]
link(get_13_5_1_1, get_13_5_1).

% [take] is a child sort of [obtain]
link(take, obtain).

% [steal_10_5] is a child sort of [obtain]
link(steal_10_5, obtain).

% [steal_10_5_1] is a child sort of [steal_10_5]
link(steal_10_5_1, steal_10_5).

% [move] is a child sort of [actions]
link(move, actions).

% [locomotion] is a child sort of [move]
link(locomotion, move).

% [go_to] is a child sort of [locomotion]
link(go_to, locomotion).

% [slide_11_2] is a child sort of [go_to]
link(slide_11_2, go_to).

% [slide_11_2_1] is a child sort of [slide_11_2]
link(slide_11_2_1, slide_11_2).

% [carry] is a child sort of [locomotion]
link(carry, locomotion).

% [leave] is a child sort of [locomotion]
link(leave, locomotion).

% [walk] is a child sort of [locomotion]
link(walk, locomotion).

% [run_51_3_2] is a child sort of [walk]
link(run_51_3_2, walk).

% [run_51_3_2_2] is a child sort of [run_51_3_2]
link(run_51_3_2_2, run_51_3_2).

% [run_51_3_2_2_1] is a child sort of [run_51_3_2_2]
link(run_51_3_2_2_1, run_51_3_2_2).

% [run_51_3_2_1] is a child sort of [run_51_3_2]
link(run_51_3_2_1, run_51_3_2).

% [thing] is a child sort of [universe]
link(thing, universe).

% [event] is a child sort of [thing]
link(event, thing).

% [activity] is a child sort of [event]
link(activity, event).

% [actions] is a child sort of [event]
link(actions, event).

% [entity] is a child sort of [thing]
link(entity, thing).

% [spatial_entity] is a child sort of [entity]
link(spatial_entity, entity).

% [office] is a child sort of [spatial_entity]
link(office, spatial_entity).

% [garden] is a child sort of [spatial_entity]
link(garden, spatial_entity).

% [tangible_entity] is a child sort of [spatial_entity]
link(tangible_entity, spatial_entity).

% [physical_object] is a child sort of [tangible_entity]
link(physical_object, tangible_entity).

% [inanimate_object] is a child sort of [physical_object]
link(inanimate_object, physical_object).

% [living_entity] is a child sort of [physical_object]
link(living_entity, physical_object).

% [john] is a child sort of [living_entity]
link(john, living_entity).

% [football] is a child sort of [living_entity]
link(football, living_entity).

% [mary] is a child sort of [living_entity]
link(mary, living_entity).

% [apple] is a child sort of [living_entity]
link(apple, living_entity).

% [daniel] is a child sort of [living_entity]
link(daniel, living_entity).

% [milk] is a child sort of [living_entity]
link(milk, living_entity).

% [bedroom] is a child sort of [spatial_entity]
link(bedroom, spatial_entity).

% [place] is a child sort of [spatial_entity]
link(place, spatial_entity).

%---------------------
%-- Section: instance
%---------------------

% Base case of [instance] relation.
% If X is a Y then X is an instance of Y.
instance(X, Y) :- is_a(X, Y).

% Closure On [instance] relation.
% X is an instance of Z if X is an instance of Y and there is a link from Y to Z.
instance(X, Z) :- instance(X, Y), link(Y, Z).

%---------------------
%-- Section: subsort
%---------------------

% Base case of [subsort] relation.
% If there is a link from X to Y in the sort hierarchy then X is a subsort of Y.
subsort(X, Y) :- link(X, Y).

% Closure On [subsort] relation.
% X is a subsort of Z if there is a link from X to Y and Y is a subsort of Z.
subsort(X, Z) :- link(X, Y), subsort(Y, Z).

% [subsort] needs the closed world assumption since it is a total boolean function.
-subsort(X, Y) :- not subsort(X, Y).

%---------------------
%-- Section: has_parent
%---------------------

% Sort X has a parent in the hierarchy if there is a link from X to some sort Y.
has_parent(X) :- link(X, Y).

% [has_parent] needs the closed world assumption since it is a total boolean function.
-has_parent(X) :- not has_parent(X).

%---------------------
%-- Section: has_child
%---------------------

% X has a child in the hierarchy if there is a link from some sort Y to X.
has_child(X) :- link(Y, X).

% [has_child] needs the closed world assumption since it is a total boolean function.
-has_child(X) :- not has_child(X).

%---------------------
%-- Section: source
%---------------------

% If sort X has no child sort, X is a source sort
source(X) :- -has_child(X).

% [source] needs the closed world assumption since it is a total boolean function.
-source(X) :- not source(X).

%---------------------
%-- Section: sink
%---------------------

% If sort X has no parent sort, X is a sink sort
sink(X) :- -has_parent(X).

% [sink] needs the closed world assumption since it is a total boolean function.
-sink(X) :- not sink(X).

%---------------------
%-- Section: Auxiliary Rules For Static Functions
%---------------------

% Function [instance] is a defined static function and has the closed world assumption.
-instance(X0, X1) :- not instance(X0, X1).

% Function [link] is a defined static function and has the closed world assumption.
-link(X0, X1) :- not link(X0, X1).

% Definition of [dom_event_object] when [event_object] is a positive boolean function.
dom_event_object(X0, X1) :- event_object(X0, X1).

% Definition of [dom_event_object] when [event_object] is a positive boolean function.
dom_event_object(X0, X1) :- -event_object(X0, X1).

% Closed world assumption holds for [dom_event_object] since [event_object] is a static function.
-dom_event_object(X0, X1) :- not dom_event_object(X0, X1).

% Function [has_child] is a defined static function and has the closed world assumption.
-has_child(X0) :- not has_child(X0).

% Function [defined_away_from] is a defined static function and has the closed world assumption.
-defined_away_from(X0) :- not defined_away_from(X0).

% Definition of [dom_actions_vn_cause] when [actions_vn_cause] is a positive boolean function.
dom_actions_vn_cause(X0, X1) :- actions_vn_cause(X0, X1).

% Definition of [dom_actions_vn_cause] when [actions_vn_cause] is a positive boolean function.
dom_actions_vn_cause(X0, X1) :- -actions_vn_cause(X0, X1).

% Closed world assumption holds for [dom_actions_vn_cause] since [actions_vn_cause] is a static function.
-dom_actions_vn_cause(X0, X1) :- not dom_actions_vn_cause(X0, X1).

% Definition of [dom_actions_vn_experiencer] when [actions_vn_experiencer] is a positive boolean function.
dom_actions_vn_experiencer(X0, X1) :- actions_vn_experiencer(X0, X1).

% Definition of [dom_actions_vn_experiencer] when [actions_vn_experiencer] is a positive boolean function.
dom_actions_vn_experiencer(X0, X1) :- -actions_vn_experiencer(X0, X1).

% Closed world assumption holds for [dom_actions_vn_experiencer] since [actions_vn_experiencer] is a static function.
-dom_actions_vn_experiencer(X0, X1) :- not dom_actions_vn_experiencer(X0, X1).

% Definition of [dom_actions_vn_pivot] when [actions_vn_pivot] is a positive boolean function.
dom_actions_vn_pivot(X0, X1) :- actions_vn_pivot(X0, X1).

% Definition of [dom_actions_vn_pivot] when [actions_vn_pivot] is a positive boolean function.
dom_actions_vn_pivot(X0, X1) :- -actions_vn_pivot(X0, X1).

% Closed world assumption holds for [dom_actions_vn_pivot] since [actions_vn_pivot] is a static function.
-dom_actions_vn_pivot(X0, X1) :- not dom_actions_vn_pivot(X0, X1).

% Definition of [dom_event_site] when [event_site] is a positive boolean function.
dom_event_site(X0, X1) :- event_site(X0, X1).

% Definition of [dom_event_site] when [event_site] is a positive boolean function.
dom_event_site(X0, X1) :- -event_site(X0, X1).

% Closed world assumption holds for [dom_event_site] since [event_site] is a static function.
-dom_event_site(X0, X1) :- not dom_event_site(X0, X1).

% Definition of [dom_actions_vn_location] when [actions_vn_location] is a positive boolean function.
dom_actions_vn_location(X0, X1) :- actions_vn_location(X0, X1).

% Definition of [dom_actions_vn_location] when [actions_vn_location] is a positive boolean function.
dom_actions_vn_location(X0, X1) :- -actions_vn_location(X0, X1).

% Closed world assumption holds for [dom_actions_vn_location] since [actions_vn_location] is a static function.
-dom_actions_vn_location(X0, X1) :- not dom_actions_vn_location(X0, X1).

% Definition of [dom_event_agent] when [event_agent] is a positive boolean function.
dom_event_agent(X0, X1) :- event_agent(X0, X1).

% Definition of [dom_event_agent] when [event_agent] is a positive boolean function.
dom_event_agent(X0, X1) :- -event_agent(X0, X1).

% Closed world assumption holds for [dom_event_agent] since [event_agent] is a static function.
-dom_event_agent(X0, X1) :- not dom_event_agent(X0, X1).

% Definition of [dom_actions_vn_beneficiary] when [actions_vn_beneficiary] is a positive boolean function.
dom_actions_vn_beneficiary(X0, X1) :- actions_vn_beneficiary(X0, X1).

% Definition of [dom_actions_vn_beneficiary] when [actions_vn_beneficiary] is a positive boolean function.
dom_actions_vn_beneficiary(X0, X1) :- -actions_vn_beneficiary(X0, X1).

% Closed world assumption holds for [dom_actions_vn_beneficiary] since [actions_vn_beneficiary] is a static function.
-dom_actions_vn_beneficiary(X0, X1) :- not dom_actions_vn_beneficiary(X0, X1).

% Definition of [dom_actions_vn_trajectory] when [actions_vn_trajectory] is a positive boolean function.
dom_actions_vn_trajectory(X0, X1) :- actions_vn_trajectory(X0, X1).

% Definition of [dom_actions_vn_trajectory] when [actions_vn_trajectory] is a positive boolean function.
dom_actions_vn_trajectory(X0, X1) :- -actions_vn_trajectory(X0, X1).

% Closed world assumption holds for [dom_actions_vn_trajectory] since [actions_vn_trajectory] is a static function.
-dom_actions_vn_trajectory(X0, X1) :- not dom_actions_vn_trajectory(X0, X1).

% Definition of [dom_event_toward] when [event_toward] is a positive boolean function.
dom_event_toward(X0, X1) :- event_toward(X0, X1).

% Definition of [dom_event_toward] when [event_toward] is a positive boolean function.
dom_event_toward(X0, X1) :- -event_toward(X0, X1).

% Closed world assumption holds for [dom_event_toward] since [event_toward] is a static function.
-dom_event_toward(X0, X1) :- not dom_event_toward(X0, X1).

% Function [defined_toward] is a defined static function and has the closed world assumption.
-defined_toward(X0) :- not defined_toward(X0).

% Definition of [dom_actions_vn_extent] when [actions_vn_extent] is a positive boolean function.
dom_actions_vn_extent(X0, X1) :- actions_vn_extent(X0, X1).

% Definition of [dom_actions_vn_extent] when [actions_vn_extent] is a positive boolean function.
dom_actions_vn_extent(X0, X1) :- -actions_vn_extent(X0, X1).

% Closed world assumption holds for [dom_actions_vn_extent] since [actions_vn_extent] is a static function.
-dom_actions_vn_extent(X0, X1) :- not dom_actions_vn_extent(X0, X1).

% Definition of [dom_actions_vn_value] when [actions_vn_value] is a positive boolean function.
dom_actions_vn_value(X0, X1) :- actions_vn_value(X0, X1).

% Definition of [dom_actions_vn_value] when [actions_vn_value] is a positive boolean function.
dom_actions_vn_value(X0, X1) :- -actions_vn_value(X0, X1).

% Closed world assumption holds for [dom_actions_vn_value] since [actions_vn_value] is a static function.
-dom_actions_vn_value(X0, X1) :- not dom_actions_vn_value(X0, X1).

% Definition of [dom_actions_vn_initial_location] when [actions_vn_initial_location] is a positive boolean function.
dom_actions_vn_initial_location(X0, X1) :- actions_vn_initial_location(X0, X1).

% Definition of [dom_actions_vn_initial_location] when [actions_vn_initial_location] is a positive boolean function.
dom_actions_vn_initial_location(X0, X1) :- -actions_vn_initial_location(X0, X1).

% Closed world assumption holds for [dom_actions_vn_initial_location] since [actions_vn_initial_location] is a static function.
-dom_actions_vn_initial_location(X0, X1) :- not dom_actions_vn_initial_location(X0, X1).

% Definition of [dom_actions_vn_coagent] when [actions_vn_coagent] is a positive boolean function.
dom_actions_vn_coagent(X0, X1) :- actions_vn_coagent(X0, X1).

% Definition of [dom_actions_vn_coagent] when [actions_vn_coagent] is a positive boolean function.
dom_actions_vn_coagent(X0, X1) :- -actions_vn_coagent(X0, X1).

% Closed world assumption holds for [dom_actions_vn_coagent] since [actions_vn_coagent] is a static function.
-dom_actions_vn_coagent(X0, X1) :- not dom_actions_vn_coagent(X0, X1).

% Definition of [dom_actions_vn_source] when [actions_vn_source] is a positive boolean function.
dom_actions_vn_source(X0, X1) :- actions_vn_source(X0, X1).

% Definition of [dom_actions_vn_source] when [actions_vn_source] is a positive boolean function.
dom_actions_vn_source(X0, X1) :- -actions_vn_source(X0, X1).

% Closed world assumption holds for [dom_actions_vn_source] since [actions_vn_source] is a static function.
-dom_actions_vn_source(X0, X1) :- not dom_actions_vn_source(X0, X1).

% Definition of [dom_actions_vn_result] when [actions_vn_result] is a positive boolean function.
dom_actions_vn_result(X0, X1) :- actions_vn_result(X0, X1).

% Definition of [dom_actions_vn_result] when [actions_vn_result] is a positive boolean function.
dom_actions_vn_result(X0, X1) :- -actions_vn_result(X0, X1).

% Closed world assumption holds for [dom_actions_vn_result] since [actions_vn_result] is a static function.
-dom_actions_vn_result(X0, X1) :- not dom_actions_vn_result(X0, X1).

% Definition of [dom_actions_vn_theme] when [actions_vn_theme] is a positive boolean function.
dom_actions_vn_theme(X0, X1) :- actions_vn_theme(X0, X1).

% Definition of [dom_actions_vn_theme] when [actions_vn_theme] is a positive boolean function.
dom_actions_vn_theme(X0, X1) :- -actions_vn_theme(X0, X1).

% Closed world assumption holds for [dom_actions_vn_theme] since [actions_vn_theme] is a static function.
-dom_actions_vn_theme(X0, X1) :- not dom_actions_vn_theme(X0, X1).

% Definition of [dom_actions_vn_attribute] when [actions_vn_attribute] is a positive boolean function.
dom_actions_vn_attribute(X0, X1) :- actions_vn_attribute(X0, X1).

% Definition of [dom_actions_vn_attribute] when [actions_vn_attribute] is a positive boolean function.
dom_actions_vn_attribute(X0, X1) :- -actions_vn_attribute(X0, X1).

% Closed world assumption holds for [dom_actions_vn_attribute] since [actions_vn_attribute] is a static function.
-dom_actions_vn_attribute(X0, X1) :- not dom_actions_vn_attribute(X0, X1).

% Definition of [dom_actions_vn_initial_state] when [actions_vn_initial_state] is a positive boolean function.
dom_actions_vn_initial_state(X0, X1) :- actions_vn_initial_state(X0, X1).

% Definition of [dom_actions_vn_initial_state] when [actions_vn_initial_state] is a positive boolean function.
dom_actions_vn_initial_state(X0, X1) :- -actions_vn_initial_state(X0, X1).

% Closed world assumption holds for [dom_actions_vn_initial_state] since [actions_vn_initial_state] is a static function.
-dom_actions_vn_initial_state(X0, X1) :- not dom_actions_vn_initial_state(X0, X1).

% Function [defined_origin] is a defined static function and has the closed world assumption.
-defined_origin(X0) :- not defined_origin(X0).

% Function [defined_object] is a defined static function and has the closed world assumption.
-defined_object(X0) :- not defined_object(X0).

% Function [defined_result] is a defined static function and has the closed world assumption.
-defined_result(X0) :- not defined_result(X0).

% Function [has_parent] is a defined static function and has the closed world assumption.
-has_parent(X0) :- not has_parent(X0).

% Definition of [dom_actions_vn_recipient] when [actions_vn_recipient] is a positive boolean function.
dom_actions_vn_recipient(X0, X1) :- actions_vn_recipient(X0, X1).

% Definition of [dom_actions_vn_recipient] when [actions_vn_recipient] is a positive boolean function.
dom_actions_vn_recipient(X0, X1) :- -actions_vn_recipient(X0, X1).

% Closed world assumption holds for [dom_actions_vn_recipient] since [actions_vn_recipient] is a static function.
-dom_actions_vn_recipient(X0, X1) :- not dom_actions_vn_recipient(X0, X1).

% Definition of [dom_actions_vn_material] when [actions_vn_material] is a positive boolean function.
dom_actions_vn_material(X0, X1) :- actions_vn_material(X0, X1).

% Definition of [dom_actions_vn_material] when [actions_vn_material] is a positive boolean function.
dom_actions_vn_material(X0, X1) :- -actions_vn_material(X0, X1).

% Closed world assumption holds for [dom_actions_vn_material] since [actions_vn_material] is a static function.
-dom_actions_vn_material(X0, X1) :- not dom_actions_vn_material(X0, X1).

% Definition of [dom_actions_vn_goal] when [actions_vn_goal] is a positive boolean function.
dom_actions_vn_goal(X0, X1) :- actions_vn_goal(X0, X1).

% Definition of [dom_actions_vn_goal] when [actions_vn_goal] is a positive boolean function.
dom_actions_vn_goal(X0, X1) :- -actions_vn_goal(X0, X1).

% Closed world assumption holds for [dom_actions_vn_goal] since [actions_vn_goal] is a static function.
-dom_actions_vn_goal(X0, X1) :- not dom_actions_vn_goal(X0, X1).

% Definition of [dom_actions_vn_reflexive] when [actions_vn_reflexive] is a positive boolean function.
dom_actions_vn_reflexive(X0, X1) :- actions_vn_reflexive(X0, X1).

% Definition of [dom_actions_vn_reflexive] when [actions_vn_reflexive] is a positive boolean function.
dom_actions_vn_reflexive(X0, X1) :- -actions_vn_reflexive(X0, X1).

% Closed world assumption holds for [dom_actions_vn_reflexive] since [actions_vn_reflexive] is a static function.
-dom_actions_vn_reflexive(X0, X1) :- not dom_actions_vn_reflexive(X0, X1).

% Definition of [dom_actions_vn_agent] when [actions_vn_agent] is a positive boolean function.
dom_actions_vn_agent(X0, X1) :- actions_vn_agent(X0, X1).

% Definition of [dom_actions_vn_agent] when [actions_vn_agent] is a positive boolean function.
dom_actions_vn_agent(X0, X1) :- -actions_vn_agent(X0, X1).

% Closed world assumption holds for [dom_actions_vn_agent] since [actions_vn_agent] is a static function.
-dom_actions_vn_agent(X0, X1) :- not dom_actions_vn_agent(X0, X1).

% Definition of [dom_actions_vn_topic] when [actions_vn_topic] is a positive boolean function.
dom_actions_vn_topic(X0, X1) :- actions_vn_topic(X0, X1).

% Definition of [dom_actions_vn_topic] when [actions_vn_topic] is a positive boolean function.
dom_actions_vn_topic(X0, X1) :- -actions_vn_topic(X0, X1).

% Closed world assumption holds for [dom_actions_vn_topic] since [actions_vn_topic] is a static function.
-dom_actions_vn_topic(X0, X1) :- not dom_actions_vn_topic(X0, X1).

% Definition of [dom_event_beneficiary] when [event_beneficiary] is a positive boolean function.
dom_event_beneficiary(X0, X1) :- event_beneficiary(X0, X1).

% Definition of [dom_event_beneficiary] when [event_beneficiary] is a positive boolean function.
dom_event_beneficiary(X0, X1) :- -event_beneficiary(X0, X1).

% Closed world assumption holds for [dom_event_beneficiary] since [event_beneficiary] is a static function.
-dom_event_beneficiary(X0, X1) :- not dom_event_beneficiary(X0, X1).

% Function [sink] is a defined static function and has the closed world assumption.
-sink(X0) :- not sink(X0).

% Definition of [dom_event_instrument] when [event_instrument] is a positive boolean function.
dom_event_instrument(X0, X1) :- event_instrument(X0, X1).

% Definition of [dom_event_instrument] when [event_instrument] is a positive boolean function.
dom_event_instrument(X0, X1) :- -event_instrument(X0, X1).

% Closed world assumption holds for [dom_event_instrument] since [event_instrument] is a static function.
-dom_event_instrument(X0, X1) :- not dom_event_instrument(X0, X1).

% Function [defined_agent] is a defined static function and has the closed world assumption.
-defined_agent(X0) :- not defined_agent(X0).

% Definition of [dom_actions_vn_cotheme] when [actions_vn_cotheme] is a positive boolean function.
dom_actions_vn_cotheme(X0, X1) :- actions_vn_cotheme(X0, X1).

% Definition of [dom_actions_vn_cotheme] when [actions_vn_cotheme] is a positive boolean function.
dom_actions_vn_cotheme(X0, X1) :- -actions_vn_cotheme(X0, X1).

% Closed world assumption holds for [dom_actions_vn_cotheme] since [actions_vn_cotheme] is a static function.
-dom_actions_vn_cotheme(X0, X1) :- not dom_actions_vn_cotheme(X0, X1).

% Function [defined_destination] is a defined static function and has the closed world assumption.
-defined_destination(X0) :- not defined_destination(X0).

% Function [is_a] is a defined static function and has the closed world assumption.
-is_a(X0, X1) :- not is_a(X0, X1).

% Function [defined_recipient] is a defined static function and has the closed world assumption.
-defined_recipient(X0) :- not defined_recipient(X0).

% Definition of [dom_actions_vn_asset] when [actions_vn_asset] is a positive boolean function.
dom_actions_vn_asset(X0, X1) :- actions_vn_asset(X0, X1).

% Definition of [dom_actions_vn_asset] when [actions_vn_asset] is a positive boolean function.
dom_actions_vn_asset(X0, X1) :- -actions_vn_asset(X0, X1).

% Closed world assumption holds for [dom_actions_vn_asset] since [actions_vn_asset] is a static function.
-dom_actions_vn_asset(X0, X1) :- not dom_actions_vn_asset(X0, X1).

% Function [defined_experiencer] is a defined static function and has the closed world assumption.
-defined_experiencer(X0) :- not defined_experiencer(X0).

% Function [defined_path] is a defined static function and has the closed world assumption.
-defined_path(X0) :- not defined_path(X0).

% Definition of [dom_actions_vn_time] when [actions_vn_time] is a positive boolean function.
dom_actions_vn_time(X0, X1) :- actions_vn_time(X0, X1).

% Definition of [dom_actions_vn_time] when [actions_vn_time] is a positive boolean function.
dom_actions_vn_time(X0, X1) :- -actions_vn_time(X0, X1).

% Closed world assumption holds for [dom_actions_vn_time] since [actions_vn_time] is a static function.
-dom_actions_vn_time(X0, X1) :- not dom_actions_vn_time(X0, X1).

% Definition of [dom_event_base] when [event_base] is a positive boolean function.
dom_event_base(X0, X1) :- event_base(X0, X1).

% Definition of [dom_event_base] when [event_base] is a positive boolean function.
dom_event_base(X0, X1) :- -event_base(X0, X1).

% Closed world assumption holds for [dom_event_base] since [event_base] is a static function.
-dom_event_base(X0, X1) :- not dom_event_base(X0, X1).

% Definition of [dom_actions_vn_instrument] when [actions_vn_instrument] is a positive boolean function.
dom_actions_vn_instrument(X0, X1) :- actions_vn_instrument(X0, X1).

% Definition of [dom_actions_vn_instrument] when [actions_vn_instrument] is a positive boolean function.
dom_actions_vn_instrument(X0, X1) :- -actions_vn_instrument(X0, X1).

% Closed world assumption holds for [dom_actions_vn_instrument] since [actions_vn_instrument] is a static function.
-dom_actions_vn_instrument(X0, X1) :- not dom_actions_vn_instrument(X0, X1).

% Definition of [dom_actions_vn_stimulus] when [actions_vn_stimulus] is a positive boolean function.
dom_actions_vn_stimulus(X0, X1) :- actions_vn_stimulus(X0, X1).

% Definition of [dom_actions_vn_stimulus] when [actions_vn_stimulus] is a positive boolean function.
dom_actions_vn_stimulus(X0, X1) :- -actions_vn_stimulus(X0, X1).

% Closed world assumption holds for [dom_actions_vn_stimulus] since [actions_vn_stimulus] is a static function.
-dom_actions_vn_stimulus(X0, X1) :- not dom_actions_vn_stimulus(X0, X1).

% Definition of [dom_actions_vn_predicate] when [actions_vn_predicate] is a positive boolean function.
dom_actions_vn_predicate(X0, X1) :- actions_vn_predicate(X0, X1).

% Definition of [dom_actions_vn_predicate] when [actions_vn_predicate] is a positive boolean function.
dom_actions_vn_predicate(X0, X1) :- -actions_vn_predicate(X0, X1).

% Closed world assumption holds for [dom_actions_vn_predicate] since [actions_vn_predicate] is a static function.
-dom_actions_vn_predicate(X0, X1) :- not dom_actions_vn_predicate(X0, X1).

% Definition of [dom_event_path] when [event_path] is a positive boolean function.
dom_event_path(X0, X1) :- event_path(X0, X1).

% Definition of [dom_event_path] when [event_path] is a positive boolean function.
dom_event_path(X0, X1) :- -event_path(X0, X1).

% Closed world assumption holds for [dom_event_path] since [event_path] is a static function.
-dom_event_path(X0, X1) :- not dom_event_path(X0, X1).

% Definition of [dom_event_experiencer] when [event_experiencer] is a positive boolean function.
dom_event_experiencer(X0, X1) :- event_experiencer(X0, X1).

% Definition of [dom_event_experiencer] when [event_experiencer] is a positive boolean function.
dom_event_experiencer(X0, X1) :- -event_experiencer(X0, X1).

% Closed world assumption holds for [dom_event_experiencer] since [event_experiencer] is a static function.
-dom_event_experiencer(X0, X1) :- not dom_event_experiencer(X0, X1).

% Function [defined_beneficiary] is a defined static function and has the closed world assumption.
-defined_beneficiary(X0) :- not defined_beneficiary(X0).

% Definition of [dom_event_donor] when [event_donor] is a positive boolean function.
dom_event_donor(X0, X1) :- event_donor(X0, X1).

% Definition of [dom_event_donor] when [event_donor] is a positive boolean function.
dom_event_donor(X0, X1) :- -event_donor(X0, X1).

% Closed world assumption holds for [dom_event_donor] since [event_donor] is a static function.
-dom_event_donor(X0, X1) :- not dom_event_donor(X0, X1).

% Definition of [dom_event_result] when [event_result] is a positive boolean function.
dom_event_result(X0, X1) :- event_result(X0, X1).

% Definition of [dom_event_result] when [event_result] is a positive boolean function.
dom_event_result(X0, X1) :- -event_result(X0, X1).

% Closed world assumption holds for [dom_event_result] since [event_result] is a static function.
-dom_event_result(X0, X1) :- not dom_event_result(X0, X1).

% Definition of [dom_actions_vn_causer] when [actions_vn_causer] is a positive boolean function.
dom_actions_vn_causer(X0, X1) :- actions_vn_causer(X0, X1).

% Definition of [dom_actions_vn_causer] when [actions_vn_causer] is a positive boolean function.
dom_actions_vn_causer(X0, X1) :- -actions_vn_causer(X0, X1).

% Closed world assumption holds for [dom_actions_vn_causer] since [actions_vn_causer] is a static function.
-dom_actions_vn_causer(X0, X1) :- not dom_actions_vn_causer(X0, X1).

% Definition of [dom_event_recipient] when [event_recipient] is a positive boolean function.
dom_event_recipient(X0, X1) :- event_recipient(X0, X1).

% Definition of [dom_event_recipient] when [event_recipient] is a positive boolean function.
dom_event_recipient(X0, X1) :- -event_recipient(X0, X1).

% Closed world assumption holds for [dom_event_recipient] since [event_recipient] is a static function.
-dom_event_recipient(X0, X1) :- not dom_event_recipient(X0, X1).

% Function [subsort] is a defined static function and has the closed world assumption.
-subsort(X0, X1) :- not subsort(X0, X1).

% Definition of [dom_actions_vn_actor] when [actions_vn_actor] is a positive boolean function.
dom_actions_vn_actor(X0, X1) :- actions_vn_actor(X0, X1).

% Definition of [dom_actions_vn_actor] when [actions_vn_actor] is a positive boolean function.
dom_actions_vn_actor(X0, X1) :- -actions_vn_actor(X0, X1).

% Closed world assumption holds for [dom_actions_vn_actor] since [actions_vn_actor] is a static function.
-dom_actions_vn_actor(X0, X1) :- not dom_actions_vn_actor(X0, X1).

% Definition of [dom_event_away_from] when [event_away_from] is a positive boolean function.
dom_event_away_from(X0, X1) :- event_away_from(X0, X1).

% Definition of [dom_event_away_from] when [event_away_from] is a positive boolean function.
dom_event_away_from(X0, X1) :- -event_away_from(X0, X1).

% Closed world assumption holds for [dom_event_away_from] since [event_away_from] is a static function.
-dom_event_away_from(X0, X1) :- not dom_event_away_from(X0, X1).

% Definition of [dom_event_origin] when [event_origin] is a positive boolean function.
dom_event_origin(X0, X1) :- event_origin(X0, X1).

% Definition of [dom_event_origin] when [event_origin] is a positive boolean function.
dom_event_origin(X0, X1) :- -event_origin(X0, X1).

% Closed world assumption holds for [dom_event_origin] since [event_origin] is a static function.
-dom_event_origin(X0, X1) :- not dom_event_origin(X0, X1).

% Definition of [dom_actions_vn_destination] when [actions_vn_destination] is a positive boolean function.
dom_actions_vn_destination(X0, X1) :- actions_vn_destination(X0, X1).

% Definition of [dom_actions_vn_destination] when [actions_vn_destination] is a positive boolean function.
dom_actions_vn_destination(X0, X1) :- -actions_vn_destination(X0, X1).

% Closed world assumption holds for [dom_actions_vn_destination] since [actions_vn_destination] is a static function.
-dom_actions_vn_destination(X0, X1) :- not dom_actions_vn_destination(X0, X1).

% Function [defined_donor] is a defined static function and has the closed world assumption.
-defined_donor(X0) :- not defined_donor(X0).

% Definition of [dom_actions_vn_product] when [actions_vn_product] is a positive boolean function.
dom_actions_vn_product(X0, X1) :- actions_vn_product(X0, X1).

% Definition of [dom_actions_vn_product] when [actions_vn_product] is a positive boolean function.
dom_actions_vn_product(X0, X1) :- -actions_vn_product(X0, X1).

% Closed world assumption holds for [dom_actions_vn_product] since [actions_vn_product] is a static function.
-dom_actions_vn_product(X0, X1) :- not dom_actions_vn_product(X0, X1).

% Definition of [dom_actions_vn_patient] when [actions_vn_patient] is a positive boolean function.
dom_actions_vn_patient(X0, X1) :- actions_vn_patient(X0, X1).

% Definition of [dom_actions_vn_patient] when [actions_vn_patient] is a positive boolean function.
dom_actions_vn_patient(X0, X1) :- -actions_vn_patient(X0, X1).

% Closed world assumption holds for [dom_actions_vn_patient] since [actions_vn_patient] is a static function.
-dom_actions_vn_patient(X0, X1) :- not dom_actions_vn_patient(X0, X1).

% Function [defined_raw_material] is a defined static function and has the closed world assumption.
-defined_raw_material(X0) :- not defined_raw_material(X0).

% Definition of [dom_event_destination] when [event_destination] is a positive boolean function.
dom_event_destination(X0, X1) :- event_destination(X0, X1).

% Definition of [dom_event_destination] when [event_destination] is a positive boolean function.
dom_event_destination(X0, X1) :- -event_destination(X0, X1).

% Closed world assumption holds for [dom_event_destination] since [event_destination] is a static function.
-dom_event_destination(X0, X1) :- not dom_event_destination(X0, X1).

% Definition of [dom_actions_vn_copatient] when [actions_vn_copatient] is a positive boolean function.
dom_actions_vn_copatient(X0, X1) :- actions_vn_copatient(X0, X1).

% Definition of [dom_actions_vn_copatient] when [actions_vn_copatient] is a positive boolean function.
dom_actions_vn_copatient(X0, X1) :- -actions_vn_copatient(X0, X1).

% Closed world assumption holds for [dom_actions_vn_copatient] since [actions_vn_copatient] is a static function.
-dom_actions_vn_copatient(X0, X1) :- not dom_actions_vn_copatient(X0, X1).

% Function [source] is a defined static function and has the closed world assumption.
-source(X0) :- not source(X0).

% Function [defined_base] is a defined static function and has the closed world assumption.
-defined_base(X0) :- not defined_base(X0).

% Function [defined_site] is a defined static function and has the closed world assumption.
-defined_site(X0) :- not defined_site(X0).

% Definition of [dom_event_raw_material] when [event_raw_material] is a positive boolean function.
dom_event_raw_material(X0, X1) :- event_raw_material(X0, X1).

% Definition of [dom_event_raw_material] when [event_raw_material] is a positive boolean function.
dom_event_raw_material(X0, X1) :- -event_raw_material(X0, X1).

% Closed world assumption holds for [dom_event_raw_material] since [event_raw_material] is a static function.
-dom_event_raw_material(X0, X1) :- not dom_event_raw_material(X0, X1).

% Function [defined_instrument] is a defined static function and has the closed world assumption.
-defined_instrument(X0) :- not defined_instrument(X0).

%---------------------
%-- Section: Axioms - State Constraints With Only Static Functions
%---------------------

% State Constraint: This condition is impossible in all states.
:- instance(X, transfer), -defined_object(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, transfer), event_donor(X, D), -instance(D, tangible_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, transfer), event_recipient(X, Y), event_donor(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, deliver), -defined_recipient(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, deliver), event_recipient(X, R), -instance(R, tangible_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, deliver), event_donor(X, Y), event_agent(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, deliver), event_recipient(X, Y), event_agent(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, lose), -defined_donor(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, lose), event_donor(X, D), -instance(D, tangible_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, receive), -defined_recipient(X).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, receive), event_recipient(X, Y).

% State Constraint for function [recipient].
event_recipient(X, Y) :- instance(X, receive), event_agent(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, take), -defined_donor(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, take), event_donor(X, D), -instance(D, tangible_entity).

% State Constraint for function [agent].
event_agent(A, B) :- instance(A, get_13_5_1), actions_vn_agent(A, B).

% State Constraint for function [object].
event_object(A, B) :- instance(A, get_13_5_1), actions_vn_asset(A, B).

% State Constraint for function [donor].
event_donor(A, B) :- instance(A, get_13_5_1), actions_vn_source(A, B).

% State Constraint for function [recipient].
event_recipient(A, B) :- instance(A, get_13_5_1), actions_vn_beneficiary(A, B).

% State Constraint for function [object].
event_object(A, B) :- instance(A, get_13_5_1), actions_vn_theme(A, B).

% State Constraint for function [agent].
event_agent(A, B) :- instance(A, get_13_5_1_1), actions_vn_agent(A, B).

% State Constraint for function [object].
event_object(A, B) :- instance(A, get_13_5_1_1), actions_vn_asset(A, B).

% State Constraint for function [recipient].
event_recipient(A, B) :- instance(A, get_13_5_1_1), actions_vn_beneficiary(A, B).

% State Constraint for function [donor].
event_donor(A, B) :- instance(A, get_13_5_1_1), actions_vn_source(A, B).

% State Constraint for function [object].
event_object(A, B) :- instance(A, get_13_5_1_1), actions_vn_theme(A, B).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), -defined_object(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_object(X, O), -instance(O, tangible_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_origin(X, Or), -instance(Or, spatial_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_destination(X, D), -instance(D, spatial_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_away_from(X, Aw), -instance(Aw, spatial_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_toward(X, T), -instance(T, spatial_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_path(X, P), -instance(P, spatial_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_object(X, Y), event_origin(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_object(X, Y), event_destination(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_object(X, Y), event_away_from(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_object(X, Y), event_toward(X, Y).

% State Constraint: This condition is impossible in all states.
:- instance(X, move), event_object(X, Y), event_path(X, Y).

% State Constraint for function [origin].
-event_origin(X, Or1) :- instance(X, move), event_origin(X, Or), #spatial_entity(Or1), #spatial_entity(Or), Or1!=Or.

% State Constraint for function [destination].
-event_destination(X, D1) :- instance(X, move), event_destination(X, D), #spatial_entity(D1), #spatial_entity(D), D1!=D.

% State Constraint: This condition is impossible in all states.
:- instance(X, locomotion), -defined_agent(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, carry), -defined_agent(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, carry), event_agent(X, A), -instance(A, tangible_entity).

% State Constraint: This condition is impossible in all states.
:- instance(X, go_to), -defined_destination(X).

% State Constraint: This condition is impossible in all states.
:- instance(X, leave), -defined_origin(X).

% State Constraint for function [object].
event_object(X, Y) :- instance(X, locomotion), event_agent(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, locomotion), event_object(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, run_51_3_2), actions_vn_theme(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, run_51_3_2), actions_vn_initial_location(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, run_51_3_2), actions_vn_destination(X, Y).

% State Constraint for function [path].
event_path(X, Y) :- instance(X, run_51_3_2), actions_vn_trajectory(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, run_51_3_2_2), actions_vn_theme(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, run_51_3_2_2), actions_vn_initial_location(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, run_51_3_2_2), actions_vn_destination(X, Y).

% State Constraint for function [path].
event_path(X, Y) :- instance(X, run_51_3_2_2), actions_vn_trajectory(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, run_51_3_2_2), actions_vn_result(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, run_51_3_2_2), actions_vn_source(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, run_51_3_2_2_1), actions_vn_theme(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, run_51_3_2_2_1), actions_vn_initial_location(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, run_51_3_2_2_1), actions_vn_destination(X, Y).

% State Constraint for function [path].
event_path(X, Y) :- instance(X, run_51_3_2_2_1), actions_vn_trajectory(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, run_51_3_2_2_1), actions_vn_result(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, run_51_3_2_2_1), actions_vn_source(X, Y).

% State Constraint for function [agent].
event_agent(A, B) :- instance(A, steal_10_5), actions_vn_agent(A, B).

% State Constraint for function [beneficiary].
event_beneficiary(A, B) :- instance(A, steal_10_5), actions_vn_beneficiary(A, B).

% State Constraint for function [donor].
event_donor(A, B) :- instance(A, steal_10_5), actions_vn_source(A, B).

% State Constraint for function [object].
event_object(A, B) :- instance(A, steal_10_5), actions_vn_theme(A, B).

% State Constraint for function [agent].
event_agent(A, B) :- instance(A, steal_10_5_1), actions_vn_agent(A, B).

% State Constraint for function [beneficiary].
event_beneficiary(A, B) :- instance(A, steal_10_5_1), actions_vn_beneficiary(A, B).

% State Constraint for function [donor].
event_donor(A, B) :- instance(A, steal_10_5_1), actions_vn_source(A, B).

% State Constraint for function [object].
event_object(A, B) :- instance(A, steal_10_5_1), actions_vn_theme(A, B).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, run_51_3_2_1), actions_vn_theme(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, run_51_3_2_1), actions_vn_initial_location(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, run_51_3_2_1), actions_vn_destination(X, Y).

% State Constraint for function [path].
event_path(X, Y) :- instance(X, run_51_3_2_1), actions_vn_trajectory(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, slide_11_2), actions_vn_agent(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, slide_11_2), actions_vn_theme(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, slide_11_2), actions_vn_destination(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, slide_11_2), actions_vn_initial_location(X, Y).

% State Constraint for function [path].
event_path(X, Y) :- instance(X, slide_11_2), actions_vn_trajectory(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, slide_11_2_1), actions_vn_agent(X, Y).

% State Constraint for function [agent].
event_agent(X, Y) :- instance(X, slide_11_2_1), actions_vn_theme(X, Y).

% State Constraint for function [destination].
event_destination(X, Y) :- instance(X, slide_11_2_1), actions_vn_destination(X, Y).

% State Constraint for function [origin].
event_origin(X, Y) :- instance(X, slide_11_2_1), actions_vn_initial_location(X, Y).

% State Constraint for function [path].
event_path(X, Y) :- instance(X, slide_11_2_1), actions_vn_trajectory(X, Y).

%---------------------
%-- Section: Axioms - Satic Function Definitions
%---------------------

% Definition for function [defined_agent].
defined_agent(X) :- event_agent(X, Y).

% Definition for function [defined_object].
defined_object(X) :- event_object(X, Y).

% Definition for function [defined_base].
defined_base(X) :- event_base(X, Y).

% Definition for function [defined_experiencer].
defined_experiencer(X) :- event_experiencer(X, Y).

% Definition for function [defined_instrument].
defined_instrument(X) :- event_instrument(X, Y).

% Definition for function [defined_donor].
defined_donor(X) :- event_donor(X, Y).

% Definition for function [defined_recipient].
defined_recipient(X) :- event_recipient(X, Y).

% Definition for function [defined_beneficiary].
defined_beneficiary(X) :- event_beneficiary(X, Y).

% Definition for function [defined_raw_material].
defined_raw_material(X) :- event_raw_material(X, Y).

% Definition for function [defined_result].
defined_result(X) :- event_result(X, Y).

% Definition for function [defined_origin].
defined_origin(X) :- event_origin(X, Y).

% Definition for function [defined_destination].
defined_destination(X) :- event_destination(X, Y).

% Definition for function [defined_away_from].
defined_away_from(X) :- event_away_from(X, Y).

% Definition for function [defined_site].
defined_site(X) :- event_site(X, Y).

% Definition for function [defined_path].
defined_path(X) :- event_path(X, Y).

% Definition for function [defined_toward].
defined_toward(X) :- event_toward(X, Y).

%---------------------
%-- Section: integer_range
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Theory - Constant Declarations
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Structure - Sort Instances
%---------------------

% Sort Instance [r1] for sort [mary].
is_a(r1, mary).

% Sort Instance [r2] for sort [milk].
is_a(r2, milk).

% Sort Instance [r3] for sort [john].
is_a(r3, john).

% Sort Instance [r4] for sort [bedroom].
is_a(r4, bedroom).

% Sort Instance [r5] for sort [daniel].
is_a(r5, daniel).

% Sort Instance [r6] for sort [office].
is_a(r6, office).

% Sort Instance [r7] for sort [apple].
is_a(r7, apple).

% Sort Instance [r8] for sort [football].
is_a(r8, football).

% Sort Instance [r9] for sort [garden].
is_a(r9, garden).

% Sort Instance [e1] for sort [get_13_5_1_1].
is_a(e1, get_13_5_1_1) :- instance(r1, entity), instance(r2, entity).

% Sort Instance [e2] for sort [slide_11_2].
is_a(e2, slide_11_2) :- instance(r3, entity), instance(r4, spatial_entity).

% Sort Instance [e3] for sort [run_51_3_2_1].
is_a(e3, run_51_3_2_1) :- instance(r5, entity), instance(r6, spatial_entity).

% Sort Instance [e4] for sort [steal_10_5_1].
is_a(e4, steal_10_5_1) :- instance(r3, entity), instance(r7, entity).

% Sort Instance [e5] for sort [get_13_5_1_1].
is_a(e5, get_13_5_1_1) :- instance(r3, entity), instance(r8, entity).

% Sort Instance [e6] for sort [run_51_3_2_1].
is_a(e6, run_51_3_2_1) :- instance(r3, entity), instance(r9, spatial_entity).

%---------------------
%-- Section: Structure - Attribute Definitions
%---------------------

% Definition of attribute [vn_agent] for instance [e1] of sort [get_13_5_1_1].
actions_vn_agent(e1, r1) :- instance(r1, entity).

% Definition of attribute [vn_theme] for instance [e1] of sort [get_13_5_1_1].
actions_vn_theme(e1, r2) :- instance(r1, entity), instance(r2, entity).

% Definition of attribute [vn_theme] for instance [e2] of sort [slide_11_2].
actions_vn_theme(e2, r3) :- instance(r3, entity).

% Definition of attribute [vn_destination] for instance [e2] of sort [slide_11_2].
actions_vn_destination(e2, r4) :- instance(r3, entity), instance(r4, spatial_entity).

% Definition of attribute [vn_theme] for instance [e3] of sort [run_51_3_2_1].
actions_vn_theme(e3, r5) :- instance(r5, entity).

% Definition of attribute [vn_destination] for instance [e3] of sort [run_51_3_2_1].
actions_vn_destination(e3, r6) :- instance(r5, entity), instance(r6, spatial_entity).

% Definition of attribute [vn_agent] for instance [e4] of sort [steal_10_5_1].
actions_vn_agent(e4, r3) :- instance(r3, entity).

% Definition of attribute [vn_theme] for instance [e4] of sort [steal_10_5_1].
actions_vn_theme(e4, r7) :- instance(r3, entity), instance(r7, entity).

% Definition of attribute [vn_agent] for instance [e5] of sort [get_13_5_1_1].
actions_vn_agent(e5, r3) :- instance(r3, entity).

% Definition of attribute [vn_theme] for instance [e5] of sort [get_13_5_1_1].
actions_vn_theme(e5, r8) :- instance(r3, entity), instance(r8, entity).

% Definition of attribute [vn_theme] for instance [e6] of sort [run_51_3_2_1].
actions_vn_theme(e6, r3) :- instance(r3, entity).

% Definition of attribute [vn_destination] for instance [e6] of sort [run_51_3_2_1].
actions_vn_destination(e6, r9) :- instance(r3, entity), instance(r9, spatial_entity).

%---------------------
%-- Section: Structure - Static Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: Auxiliary Rules For Fluent Functions
%---------------------

% Law Of Inertia for positive boolean function [is_outside].
is_outside(X0, X1, I+1) :- is_outside(X0, X1, I), not -is_outside(X0, X1, I+1), dom_is_outside(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_outside].
-is_outside(X0, X1, I+1) :- -is_outside(X0, X1, I), not is_outside(X0, X1, I+1), dom_is_outside(X0, X1, I+1).

% Definition of positive boolean function [dom_is_outside].
dom_is_outside(X0, X1, I) :- is_outside(X0, X1, I).

% Definition of negative boolean function [dom_is_outside].
dom_is_outside(X0, X1, I) :- -is_outside(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_outside].
dom_is_outside(X0, X1, I+1) :- dom_is_outside(X0, X1, I), not -dom_is_outside(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_outside].
-dom_is_outside(X0, X1, I+1) :- -dom_is_outside(X0, X1, I), not dom_is_outside(X0, X1, I+1).

% Law Of Inertia for positive boolean function [contained_in].
contained_in(X0, X1, I+1) :- contained_in(X0, X1, I), not -contained_in(X0, X1, I+1), dom_contained_in(X0, X1, I+1).

% Law Of Inertia for negative boolean function [contained_in].
-contained_in(X0, X1, I+1) :- -contained_in(X0, X1, I), not contained_in(X0, X1, I+1), dom_contained_in(X0, X1, I+1).

% Definition of positive boolean function [dom_contained_in].
dom_contained_in(X0, X1, I) :- contained_in(X0, X1, I).

% Definition of negative boolean function [dom_contained_in].
dom_contained_in(X0, X1, I) :- -contained_in(X0, X1, I).

% Law Of Inertia for positive domain function [dom_contained_in].
dom_contained_in(X0, X1, I+1) :- dom_contained_in(X0, X1, I), not -dom_contained_in(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_contained_in].
-dom_contained_in(X0, X1, I+1) :- -dom_contained_in(X0, X1, I), not dom_contained_in(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_near].
is_near(X0, X1, I+1) :- is_near(X0, X1, I), not -is_near(X0, X1, I+1), dom_is_near(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_near].
-is_near(X0, X1, I+1) :- -is_near(X0, X1, I), not is_near(X0, X1, I+1), dom_is_near(X0, X1, I+1).

% Definition of positive boolean function [dom_is_near].
dom_is_near(X0, X1, I) :- is_near(X0, X1, I).

% Definition of negative boolean function [dom_is_near].
dom_is_near(X0, X1, I) :- -is_near(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_near].
dom_is_near(X0, X1, I+1) :- dom_is_near(X0, X1, I), not -dom_is_near(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_near].
-dom_is_near(X0, X1, I+1) :- -dom_is_near(X0, X1, I), not dom_is_near(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_opposite].
is_opposite(X0, X1, I+1) :- is_opposite(X0, X1, I), not -is_opposite(X0, X1, I+1), dom_is_opposite(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_opposite].
-is_opposite(X0, X1, I+1) :- -is_opposite(X0, X1, I), not is_opposite(X0, X1, I+1), dom_is_opposite(X0, X1, I+1).

% Definition of positive boolean function [dom_is_opposite].
dom_is_opposite(X0, X1, I) :- is_opposite(X0, X1, I).

% Definition of negative boolean function [dom_is_opposite].
dom_is_opposite(X0, X1, I) :- -is_opposite(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_opposite].
dom_is_opposite(X0, X1, I+1) :- dom_is_opposite(X0, X1, I), not -dom_is_opposite(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_opposite].
-dom_is_opposite(X0, X1, I+1) :- -dom_is_opposite(X0, X1, I), not dom_is_opposite(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_on].
is_on(X0, X1, I+1) :- is_on(X0, X1, I), not -is_on(X0, X1, I+1), dom_is_on(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_on].
-is_on(X0, X1, I+1) :- -is_on(X0, X1, I), not is_on(X0, X1, I+1), dom_is_on(X0, X1, I+1).

% Definition of positive boolean function [dom_is_on].
dom_is_on(X0, X1, I) :- is_on(X0, X1, I).

% Definition of negative boolean function [dom_is_on].
dom_is_on(X0, X1, I) :- -is_on(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_on].
dom_is_on(X0, X1, I+1) :- dom_is_on(X0, X1, I), not -dom_is_on(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_on].
-dom_is_on(X0, X1, I+1) :- -dom_is_on(X0, X1, I), not dom_is_on(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_under].
is_under(X0, X1, I+1) :- is_under(X0, X1, I), not -is_under(X0, X1, I+1), dom_is_under(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_under].
-is_under(X0, X1, I+1) :- -is_under(X0, X1, I), not is_under(X0, X1, I+1), dom_is_under(X0, X1, I+1).

% Definition of positive boolean function [dom_is_under].
dom_is_under(X0, X1, I) :- is_under(X0, X1, I).

% Definition of negative boolean function [dom_is_under].
dom_is_under(X0, X1, I) :- -is_under(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_under].
dom_is_under(X0, X1, I+1) :- dom_is_under(X0, X1, I), not -dom_is_under(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_under].
-dom_is_under(X0, X1, I+1) :- -dom_is_under(X0, X1, I), not dom_is_under(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_confined].
is_confined(X0, I+1) :- is_confined(X0, I), not -is_confined(X0, I+1), dom_is_confined(X0, I+1).

% Law Of Inertia for negative boolean function [is_confined].
-is_confined(X0, I+1) :- -is_confined(X0, I), not is_confined(X0, I+1), dom_is_confined(X0, I+1).

% Definition of positive boolean function [dom_is_confined].
dom_is_confined(X0, I) :- is_confined(X0, I).

% Definition of negative boolean function [dom_is_confined].
dom_is_confined(X0, I) :- -is_confined(X0, I).

% Law Of Inertia for positive domain function [dom_is_confined].
dom_is_confined(X0, I+1) :- dom_is_confined(X0, I), not -dom_is_confined(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_confined].
-dom_is_confined(X0, I+1) :- -dom_is_confined(X0, I), not dom_is_confined(X0, I+1).

% Law Of Inertia for positive boolean function [is_between].
is_between(X0, X1, I+1) :- is_between(X0, X1, I), not -is_between(X0, X1, I+1), dom_is_between(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_between].
-is_between(X0, X1, I+1) :- -is_between(X0, X1, I), not is_between(X0, X1, I+1), dom_is_between(X0, X1, I+1).

% Definition of positive boolean function [dom_is_between].
dom_is_between(X0, X1, I) :- is_between(X0, X1, I).

% Definition of negative boolean function [dom_is_between].
dom_is_between(X0, X1, I) :- -is_between(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_between].
dom_is_between(X0, X1, I+1) :- dom_is_between(X0, X1, I), not -dom_is_between(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_between].
-dom_is_between(X0, X1, I+1) :- -dom_is_between(X0, X1, I), not dom_is_between(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_held].
is_held(X0, I+1) :- is_held(X0, I), not -is_held(X0, I+1), dom_is_held(X0, I+1).

% Law Of Inertia for negative boolean function [is_held].
-is_held(X0, I+1) :- -is_held(X0, I), not is_held(X0, I+1), dom_is_held(X0, I+1).

% Definition of positive boolean function [dom_is_held].
dom_is_held(X0, I) :- is_held(X0, I).

% Definition of negative boolean function [dom_is_held].
dom_is_held(X0, I) :- -is_held(X0, I).

% Law Of Inertia for positive domain function [dom_is_held].
dom_is_held(X0, I+1) :- dom_is_held(X0, I), not -dom_is_held(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_held].
-dom_is_held(X0, I+1) :- -dom_is_held(X0, I), not dom_is_held(X0, I+1).

% Law Of Inertia for positive boolean function [location].
location(X0, X1, I+1) :- location(X0, X1, I), not -location(X0, X1, I+1), dom_location(X0, X1, I+1).

% Law Of Inertia for negative boolean function [location].
-location(X0, X1, I+1) :- -location(X0, X1, I), not location(X0, X1, I+1), dom_location(X0, X1, I+1).

% Definition of positive boolean function [dom_location].
dom_location(X0, X1, I) :- location(X0, X1, I).

% Definition of negative boolean function [dom_location].
dom_location(X0, X1, I) :- -location(X0, X1, I).

% Law Of Inertia for positive domain function [dom_location].
dom_location(X0, X1, I+1) :- dom_location(X0, X1, I), not -dom_location(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_location].
-dom_location(X0, X1, I+1) :- -dom_location(X0, X1, I), not dom_location(X0, X1, I+1).

% Law Of Inertia for positive boolean function [abuts].
abuts(X0, X1, I+1) :- abuts(X0, X1, I), not -abuts(X0, X1, I+1), dom_abuts(X0, X1, I+1).

% Law Of Inertia for negative boolean function [abuts].
-abuts(X0, X1, I+1) :- -abuts(X0, X1, I), not abuts(X0, X1, I+1), dom_abuts(X0, X1, I+1).

% Definition of positive boolean function [dom_abuts].
dom_abuts(X0, X1, I) :- abuts(X0, X1, I).

% Definition of negative boolean function [dom_abuts].
dom_abuts(X0, X1, I) :- -abuts(X0, X1, I).

% Law Of Inertia for positive domain function [dom_abuts].
dom_abuts(X0, X1, I+1) :- dom_abuts(X0, X1, I), not -dom_abuts(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_abuts].
-dom_abuts(X0, X1, I+1) :- -dom_abuts(X0, X1, I), not dom_abuts(X0, X1, I+1).

% Law Of Inertia for positive boolean function [blocked_with].
blocked_with(X0, X1, I+1) :- blocked_with(X0, X1, I), not -blocked_with(X0, X1, I+1), dom_blocked_with(X0, X1, I+1).

% Law Of Inertia for negative boolean function [blocked_with].
-blocked_with(X0, X1, I+1) :- -blocked_with(X0, X1, I), not blocked_with(X0, X1, I+1), dom_blocked_with(X0, X1, I+1).

% Definition of positive boolean function [dom_blocked_with].
dom_blocked_with(X0, X1, I) :- blocked_with(X0, X1, I).

% Definition of negative boolean function [dom_blocked_with].
dom_blocked_with(X0, X1, I) :- -blocked_with(X0, X1, I).

% Law Of Inertia for positive domain function [dom_blocked_with].
dom_blocked_with(X0, X1, I+1) :- dom_blocked_with(X0, X1, I), not -dom_blocked_with(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_blocked_with].
-dom_blocked_with(X0, X1, I+1) :- -dom_blocked_with(X0, X1, I), not dom_blocked_with(X0, X1, I+1).

% Law Of Inertia for positive boolean function [held_by].
held_by(X0, X1, I+1) :- held_by(X0, X1, I), not -held_by(X0, X1, I+1), dom_held_by(X0, X1, I+1).

% Law Of Inertia for negative boolean function [held_by].
-held_by(X0, X1, I+1) :- -held_by(X0, X1, I), not held_by(X0, X1, I+1), dom_held_by(X0, X1, I+1).

% Definition of positive boolean function [dom_held_by].
dom_held_by(X0, X1, I) :- held_by(X0, X1, I).

% Definition of negative boolean function [dom_held_by].
dom_held_by(X0, X1, I) :- -held_by(X0, X1, I).

% Law Of Inertia for positive domain function [dom_held_by].
dom_held_by(X0, X1, I+1) :- dom_held_by(X0, X1, I), not -dom_held_by(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_held_by].
-dom_held_by(X0, X1, I+1) :- -dom_held_by(X0, X1, I), not dom_held_by(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_contained].
is_contained(X0, I+1) :- is_contained(X0, I), not -is_contained(X0, I+1), dom_is_contained(X0, I+1).

% Law Of Inertia for negative boolean function [is_contained].
-is_contained(X0, I+1) :- -is_contained(X0, I), not is_contained(X0, I+1), dom_is_contained(X0, I+1).

% Definition of positive boolean function [dom_is_contained].
dom_is_contained(X0, I) :- is_contained(X0, I).

% Definition of negative boolean function [dom_is_contained].
dom_is_contained(X0, I) :- -is_contained(X0, I).

% Law Of Inertia for positive domain function [dom_is_contained].
dom_is_contained(X0, I+1) :- dom_is_contained(X0, I), not -dom_is_contained(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_contained].
-dom_is_contained(X0, I+1) :- -dom_is_contained(X0, I), not dom_is_contained(X0, I+1).

% Law Of Inertia for positive boolean function [is_beside].
is_beside(X0, X1, I+1) :- is_beside(X0, X1, I), not -is_beside(X0, X1, I+1), dom_is_beside(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_beside].
-is_beside(X0, X1, I+1) :- -is_beside(X0, X1, I), not is_beside(X0, X1, I+1), dom_is_beside(X0, X1, I+1).

% Definition of positive boolean function [dom_is_beside].
dom_is_beside(X0, X1, I) :- is_beside(X0, X1, I).

% Definition of negative boolean function [dom_is_beside].
dom_is_beside(X0, X1, I) :- -is_beside(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_beside].
dom_is_beside(X0, X1, I+1) :- dom_is_beside(X0, X1, I), not -dom_is_beside(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_beside].
-dom_is_beside(X0, X1, I+1) :- -dom_is_beside(X0, X1, I), not dom_is_beside(X0, X1, I+1).

% Law Of Inertia for positive boolean function [known_to].
known_to(X0, X1, I+1) :- known_to(X0, X1, I), not -known_to(X0, X1, I+1), dom_known_to(X0, X1, I+1).

% Law Of Inertia for negative boolean function [known_to].
-known_to(X0, X1, I+1) :- -known_to(X0, X1, I), not known_to(X0, X1, I+1), dom_known_to(X0, X1, I+1).

% Definition of positive boolean function [dom_known_to].
dom_known_to(X0, X1, I) :- known_to(X0, X1, I).

% Definition of negative boolean function [dom_known_to].
dom_known_to(X0, X1, I) :- -known_to(X0, X1, I).

% Law Of Inertia for positive domain function [dom_known_to].
dom_known_to(X0, X1, I+1) :- dom_known_to(X0, X1, I), not -dom_known_to(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_known_to].
-dom_known_to(X0, X1, I+1) :- -dom_known_to(X0, X1, I), not dom_known_to(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_at].
is_at(X0, X1, I+1) :- is_at(X0, X1, I), not -is_at(X0, X1, I+1), dom_is_at(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_at].
-is_at(X0, X1, I+1) :- -is_at(X0, X1, I), not is_at(X0, X1, I+1), dom_is_at(X0, X1, I+1).

% Definition of positive boolean function [dom_is_at].
dom_is_at(X0, X1, I) :- is_at(X0, X1, I).

% Definition of negative boolean function [dom_is_at].
dom_is_at(X0, X1, I) :- -is_at(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_at].
dom_is_at(X0, X1, I+1) :- dom_is_at(X0, X1, I), not -dom_is_at(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_at].
-dom_is_at(X0, X1, I+1) :- -dom_is_at(X0, X1, I), not dom_is_at(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_above].
is_above(X0, X1, I+1) :- is_above(X0, X1, I), not -is_above(X0, X1, I+1), dom_is_above(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_above].
-is_above(X0, X1, I+1) :- -is_above(X0, X1, I), not is_above(X0, X1, I+1), dom_is_above(X0, X1, I+1).

% Definition of positive boolean function [dom_is_above].
dom_is_above(X0, X1, I) :- is_above(X0, X1, I).

% Definition of negative boolean function [dom_is_above].
dom_is_above(X0, X1, I) :- -is_above(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_above].
dom_is_above(X0, X1, I+1) :- dom_is_above(X0, X1, I), not -dom_is_above(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_above].
-dom_is_above(X0, X1, I+1) :- -dom_is_above(X0, X1, I), not dom_is_above(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_along].
is_along(X0, X1, I+1) :- is_along(X0, X1, I), not -is_along(X0, X1, I+1), dom_is_along(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_along].
-is_along(X0, X1, I+1) :- -is_along(X0, X1, I), not is_along(X0, X1, I+1), dom_is_along(X0, X1, I+1).

% Definition of positive boolean function [dom_is_along].
dom_is_along(X0, X1, I) :- is_along(X0, X1, I).

% Definition of negative boolean function [dom_is_along].
dom_is_along(X0, X1, I) :- -is_along(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_along].
dom_is_along(X0, X1, I+1) :- dom_is_along(X0, X1, I), not -dom_is_along(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_along].
-dom_is_along(X0, X1, I+1) :- -dom_is_along(X0, X1, I), not dom_is_along(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_over].
is_over(X0, X1, I+1) :- is_over(X0, X1, I), not -is_over(X0, X1, I+1), dom_is_over(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_over].
-is_over(X0, X1, I+1) :- -is_over(X0, X1, I), not is_over(X0, X1, I+1), dom_is_over(X0, X1, I+1).

% Definition of positive boolean function [dom_is_over].
dom_is_over(X0, X1, I) :- is_over(X0, X1, I).

% Definition of negative boolean function [dom_is_over].
dom_is_over(X0, X1, I) :- -is_over(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_over].
dom_is_over(X0, X1, I+1) :- dom_is_over(X0, X1, I), not -dom_is_over(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_over].
-dom_is_over(X0, X1, I+1) :- -dom_is_over(X0, X1, I), not dom_is_over(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_inside].
is_inside(X0, X1, I+1) :- is_inside(X0, X1, I), not -is_inside(X0, X1, I+1), dom_is_inside(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_inside].
-is_inside(X0, X1, I+1) :- -is_inside(X0, X1, I), not is_inside(X0, X1, I+1), dom_is_inside(X0, X1, I+1).

% Definition of positive boolean function [dom_is_inside].
dom_is_inside(X0, X1, I) :- is_inside(X0, X1, I).

% Definition of negative boolean function [dom_is_inside].
dom_is_inside(X0, X1, I) :- -is_inside(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_inside].
dom_is_inside(X0, X1, I+1) :- dom_is_inside(X0, X1, I), not -dom_is_inside(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_inside].
-dom_is_inside(X0, X1, I+1) :- -dom_is_inside(X0, X1, I), not dom_is_inside(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_closed].
is_closed(X0, I+1) :- is_closed(X0, I), not -is_closed(X0, I+1), dom_is_closed(X0, I+1).

% Law Of Inertia for negative boolean function [is_closed].
-is_closed(X0, I+1) :- -is_closed(X0, I), not is_closed(X0, I+1), dom_is_closed(X0, I+1).

% Definition of positive boolean function [dom_is_closed].
dom_is_closed(X0, I) :- is_closed(X0, I).

% Definition of negative boolean function [dom_is_closed].
dom_is_closed(X0, I) :- -is_closed(X0, I).

% Law Of Inertia for positive domain function [dom_is_closed].
dom_is_closed(X0, I+1) :- dom_is_closed(X0, I), not -dom_is_closed(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_closed].
-dom_is_closed(X0, I+1) :- -dom_is_closed(X0, I), not dom_is_closed(X0, I+1).

% Law Of Inertia for positive boolean function [content].
content(X0, X1, I+1) :- content(X0, X1, I), not -content(X0, X1, I+1), dom_content(X0, X1, I+1).

% Law Of Inertia for negative boolean function [content].
-content(X0, X1, I+1) :- -content(X0, X1, I), not content(X0, X1, I+1), dom_content(X0, X1, I+1).

% Definition of positive boolean function [dom_content].
dom_content(X0, X1, I) :- content(X0, X1, I).

% Definition of negative boolean function [dom_content].
dom_content(X0, X1, I) :- -content(X0, X1, I).

% Law Of Inertia for positive domain function [dom_content].
dom_content(X0, X1, I+1) :- dom_content(X0, X1, I), not -dom_content(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_content].
-dom_content(X0, X1, I+1) :- -dom_content(X0, X1, I), not dom_content(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_restrained].
is_restrained(X0, I+1) :- is_restrained(X0, I), not -is_restrained(X0, I+1), dom_is_restrained(X0, I+1).

% Law Of Inertia for negative boolean function [is_restrained].
-is_restrained(X0, I+1) :- -is_restrained(X0, I), not is_restrained(X0, I+1), dom_is_restrained(X0, I+1).

% Definition of positive boolean function [dom_is_restrained].
dom_is_restrained(X0, I) :- is_restrained(X0, I).

% Definition of negative boolean function [dom_is_restrained].
dom_is_restrained(X0, I) :- -is_restrained(X0, I).

% Law Of Inertia for positive domain function [dom_is_restrained].
dom_is_restrained(X0, I+1) :- dom_is_restrained(X0, I), not -dom_is_restrained(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_restrained].
-dom_is_restrained(X0, I+1) :- -dom_is_restrained(X0, I), not dom_is_restrained(X0, I+1).

% Law Of Inertia for positive boolean function [is_in_front_of].
is_in_front_of(X0, X1, I+1) :- is_in_front_of(X0, X1, I), not -is_in_front_of(X0, X1, I+1), dom_is_in_front_of(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_in_front_of].
-is_in_front_of(X0, X1, I+1) :- -is_in_front_of(X0, X1, I), not is_in_front_of(X0, X1, I+1), dom_is_in_front_of(X0, X1, I+1).

% Definition of positive boolean function [dom_is_in_front_of].
dom_is_in_front_of(X0, X1, I) :- is_in_front_of(X0, X1, I).

% Definition of negative boolean function [dom_is_in_front_of].
dom_is_in_front_of(X0, X1, I) :- -is_in_front_of(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_in_front_of].
dom_is_in_front_of(X0, X1, I+1) :- dom_is_in_front_of(X0, X1, I), not -dom_is_in_front_of(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_in_front_of].
-dom_is_in_front_of(X0, X1, I+1) :- -dom_is_in_front_of(X0, X1, I), not dom_is_in_front_of(X0, X1, I+1).

% Law Of Inertia for positive boolean function [has_part].
has_part(X0, X1, I+1) :- has_part(X0, X1, I), not -has_part(X0, X1, I+1), dom_has_part(X0, X1, I+1).

% Law Of Inertia for negative boolean function [has_part].
-has_part(X0, X1, I+1) :- -has_part(X0, X1, I), not has_part(X0, X1, I+1), dom_has_part(X0, X1, I+1).

% Definition of positive boolean function [dom_has_part].
dom_has_part(X0, X1, I) :- has_part(X0, X1, I).

% Definition of negative boolean function [dom_has_part].
dom_has_part(X0, X1, I) :- -has_part(X0, X1, I).

% Law Of Inertia for positive domain function [dom_has_part].
dom_has_part(X0, X1, I+1) :- dom_has_part(X0, X1, I), not -dom_has_part(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_has_part].
-dom_has_part(X0, X1, I+1) :- -dom_has_part(X0, X1, I), not dom_has_part(X0, X1, I+1).

% Law Of Inertia for positive boolean function [possesses].
possesses(X0, X1, I+1) :- possesses(X0, X1, I), not -possesses(X0, X1, I+1), dom_possesses(X0, X1, I+1).

% Law Of Inertia for negative boolean function [possesses].
-possesses(X0, X1, I+1) :- -possesses(X0, X1, I), not possesses(X0, X1, I+1), dom_possesses(X0, X1, I+1).

% Definition of positive boolean function [dom_possesses].
dom_possesses(X0, X1, I) :- possesses(X0, X1, I).

% Definition of negative boolean function [dom_possesses].
dom_possesses(X0, X1, I) :- -possesses(X0, X1, I).

% Law Of Inertia for positive domain function [dom_possesses].
dom_possesses(X0, X1, I+1) :- dom_possesses(X0, X1, I), not -dom_possesses(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_possesses].
-dom_possesses(X0, X1, I+1) :- -dom_possesses(X0, X1, I), not dom_possesses(X0, X1, I+1).

% Law Of Inertia for positive boolean function [encloses].
encloses(X0, X1, I+1) :- encloses(X0, X1, I), not -encloses(X0, X1, I+1), dom_encloses(X0, X1, I+1).

% Law Of Inertia for negative boolean function [encloses].
-encloses(X0, X1, I+1) :- -encloses(X0, X1, I), not encloses(X0, X1, I+1), dom_encloses(X0, X1, I+1).

% Definition of positive boolean function [dom_encloses].
dom_encloses(X0, X1, I) :- encloses(X0, X1, I).

% Definition of negative boolean function [dom_encloses].
dom_encloses(X0, X1, I) :- -encloses(X0, X1, I).

% Law Of Inertia for positive domain function [dom_encloses].
dom_encloses(X0, X1, I+1) :- dom_encloses(X0, X1, I), not -dom_encloses(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_encloses].
-dom_encloses(X0, X1, I+1) :- -dom_encloses(X0, X1, I), not dom_encloses(X0, X1, I+1).

% Law Of Inertia for positive boolean function [accessible_to].
accessible_to(X0, X1, I+1) :- accessible_to(X0, X1, I), not -accessible_to(X0, X1, I+1), dom_accessible_to(X0, X1, I+1).

% Law Of Inertia for negative boolean function [accessible_to].
-accessible_to(X0, X1, I+1) :- -accessible_to(X0, X1, I), not accessible_to(X0, X1, I+1), dom_accessible_to(X0, X1, I+1).

% Definition of positive boolean function [dom_accessible_to].
dom_accessible_to(X0, X1, I) :- accessible_to(X0, X1, I).

% Definition of negative boolean function [dom_accessible_to].
dom_accessible_to(X0, X1, I) :- -accessible_to(X0, X1, I).

% Law Of Inertia for positive domain function [dom_accessible_to].
dom_accessible_to(X0, X1, I+1) :- dom_accessible_to(X0, X1, I), not -dom_accessible_to(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_accessible_to].
-dom_accessible_to(X0, X1, I+1) :- -dom_accessible_to(X0, X1, I), not dom_accessible_to(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_behind].
is_behind(X0, X1, I+1) :- is_behind(X0, X1, I), not -is_behind(X0, X1, I+1), dom_is_behind(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_behind].
-is_behind(X0, X1, I+1) :- -is_behind(X0, X1, I), not is_behind(X0, X1, I+1), dom_is_behind(X0, X1, I+1).

% Definition of positive boolean function [dom_is_behind].
dom_is_behind(X0, X1, I) :- is_behind(X0, X1, I).

% Definition of negative boolean function [dom_is_behind].
dom_is_behind(X0, X1, I) :- -is_behind(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_behind].
dom_is_behind(X0, X1, I+1) :- dom_is_behind(X0, X1, I), not -dom_is_behind(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_behind].
-dom_is_behind(X0, X1, I+1) :- -dom_is_behind(X0, X1, I), not dom_is_behind(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_known].
is_known(X0, I+1) :- is_known(X0, I), not -is_known(X0, I+1), dom_is_known(X0, I+1).

% Law Of Inertia for negative boolean function [is_known].
-is_known(X0, I+1) :- -is_known(X0, I), not is_known(X0, I+1), dom_is_known(X0, I+1).

% Definition of positive boolean function [dom_is_known].
dom_is_known(X0, I) :- is_known(X0, I).

% Definition of negative boolean function [dom_is_known].
dom_is_known(X0, I) :- -is_known(X0, I).

% Law Of Inertia for positive domain function [dom_is_known].
dom_is_known(X0, I+1) :- dom_is_known(X0, I), not -dom_is_known(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_known].
-dom_is_known(X0, I+1) :- -dom_is_known(X0, I), not dom_is_known(X0, I+1).

% Law Of Inertia for positive boolean function [is_touching].
is_touching(X0, X1, I+1) :- is_touching(X0, X1, I), not -is_touching(X0, X1, I+1), dom_is_touching(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_touching].
-is_touching(X0, X1, I+1) :- -is_touching(X0, X1, I), not is_touching(X0, X1, I+1), dom_is_touching(X0, X1, I+1).

% Definition of positive boolean function [dom_is_touching].
dom_is_touching(X0, X1, I) :- is_touching(X0, X1, I).

% Definition of negative boolean function [dom_is_touching].
dom_is_touching(X0, X1, I) :- -is_touching(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_touching].
dom_is_touching(X0, X1, I+1) :- dom_is_touching(X0, X1, I), not -dom_is_touching(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_touching].
-dom_is_touching(X0, X1, I+1) :- -dom_is_touching(X0, X1, I), not dom_is_touching(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_accessible].
is_accessible(X0, I+1) :- is_accessible(X0, I), not -is_accessible(X0, I+1), dom_is_accessible(X0, I+1).

% Law Of Inertia for negative boolean function [is_accessible].
-is_accessible(X0, I+1) :- -is_accessible(X0, I), not is_accessible(X0, I+1), dom_is_accessible(X0, I+1).

% Definition of positive boolean function [dom_is_accessible].
dom_is_accessible(X0, I) :- is_accessible(X0, I).

% Definition of negative boolean function [dom_is_accessible].
dom_is_accessible(X0, I) :- -is_accessible(X0, I).

% Law Of Inertia for positive domain function [dom_is_accessible].
dom_is_accessible(X0, I+1) :- dom_is_accessible(X0, I), not -dom_is_accessible(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_accessible].
-dom_is_accessible(X0, I+1) :- -dom_is_accessible(X0, I), not dom_is_accessible(X0, I+1).

% Law Of Inertia for positive boolean function [shut_out_of].
shut_out_of(X0, X1, I+1) :- shut_out_of(X0, X1, I), not -shut_out_of(X0, X1, I+1), dom_shut_out_of(X0, X1, I+1).

% Law Of Inertia for negative boolean function [shut_out_of].
-shut_out_of(X0, X1, I+1) :- -shut_out_of(X0, X1, I), not shut_out_of(X0, X1, I+1), dom_shut_out_of(X0, X1, I+1).

% Definition of positive boolean function [dom_shut_out_of].
dom_shut_out_of(X0, X1, I) :- shut_out_of(X0, X1, I).

% Definition of negative boolean function [dom_shut_out_of].
dom_shut_out_of(X0, X1, I) :- -shut_out_of(X0, X1, I).

% Law Of Inertia for positive domain function [dom_shut_out_of].
dom_shut_out_of(X0, X1, I+1) :- dom_shut_out_of(X0, X1, I), not -dom_shut_out_of(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_shut_out_of].
-dom_shut_out_of(X0, X1, I+1) :- -dom_shut_out_of(X0, X1, I), not dom_shut_out_of(X0, X1, I+1).

% Law Of Inertia for positive boolean function [confined_to].
confined_to(X0, X1, I+1) :- confined_to(X0, X1, I), not -confined_to(X0, X1, I+1), dom_confined_to(X0, X1, I+1).

% Law Of Inertia for negative boolean function [confined_to].
-confined_to(X0, X1, I+1) :- -confined_to(X0, X1, I), not confined_to(X0, X1, I+1), dom_confined_to(X0, X1, I+1).

% Definition of positive boolean function [dom_confined_to].
dom_confined_to(X0, X1, I) :- confined_to(X0, X1, I).

% Definition of negative boolean function [dom_confined_to].
dom_confined_to(X0, X1, I) :- -confined_to(X0, X1, I).

% Law Of Inertia for positive domain function [dom_confined_to].
dom_confined_to(X0, X1, I+1) :- dom_confined_to(X0, X1, I), not -dom_confined_to(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_confined_to].
-dom_confined_to(X0, X1, I+1) :- -dom_confined_to(X0, X1, I), not dom_confined_to(X0, X1, I+1).

% Law Of Inertia for positive boolean function [is_blocked].
is_blocked(X0, I+1) :- is_blocked(X0, I), not -is_blocked(X0, I+1), dom_is_blocked(X0, I+1).

% Law Of Inertia for negative boolean function [is_blocked].
-is_blocked(X0, I+1) :- -is_blocked(X0, I), not is_blocked(X0, I+1), dom_is_blocked(X0, I+1).

% Definition of positive boolean function [dom_is_blocked].
dom_is_blocked(X0, I) :- is_blocked(X0, I).

% Definition of negative boolean function [dom_is_blocked].
dom_is_blocked(X0, I) :- -is_blocked(X0, I).

% Law Of Inertia for positive domain function [dom_is_blocked].
dom_is_blocked(X0, I+1) :- dom_is_blocked(X0, I), not -dom_is_blocked(X0, I+1).

% Law Of Inertia for negated domain functions [dom_is_blocked].
-dom_is_blocked(X0, I+1) :- -dom_is_blocked(X0, I), not dom_is_blocked(X0, I+1).

% Law Of Inertia for positive boolean function [is_below].
is_below(X0, X1, I+1) :- is_below(X0, X1, I), not -is_below(X0, X1, I+1), dom_is_below(X0, X1, I+1).

% Law Of Inertia for negative boolean function [is_below].
-is_below(X0, X1, I+1) :- -is_below(X0, X1, I), not is_below(X0, X1, I+1), dom_is_below(X0, X1, I+1).

% Definition of positive boolean function [dom_is_below].
dom_is_below(X0, X1, I) :- is_below(X0, X1, I).

% Definition of negative boolean function [dom_is_below].
dom_is_below(X0, X1, I) :- -is_below(X0, X1, I).

% Law Of Inertia for positive domain function [dom_is_below].
dom_is_below(X0, X1, I+1) :- dom_is_below(X0, X1, I), not -dom_is_below(X0, X1, I+1).

% Law Of Inertia for negated domain functions [dom_is_below].
-dom_is_below(X0, X1, I+1) :- -dom_is_below(X0, X1, I), not dom_is_below(X0, X1, I+1).

%---------------------
%-- Section: Axioms - Dynamic Causal Laws
%---------------------

% TS is the Time Step Variable.
-possesses(D, O, TS+1) :- event_donor(X, D), event_object(X, O), occurs(X, TS), instance(X, transfer).

% TS is the Time Step Variable.
possesses(R, O, TS+1) :- event_recipient(X, R), event_object(X, O), occurs(X, TS), instance(X, transfer).

% TS is the Time Step Variable.
location(O, D, TS+1) :- event_object(X, O), event_destination(X, D), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
location(O, P, TS+1) :- event_object(X, O), event_destination(X, D), -instance(D, tangible_entity), location(D, P, TS), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_near(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_near(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_above(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_above(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_below(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_below(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_along(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_along(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_at(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_at(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_beside(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_beside(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_along(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_along(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_between(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_between(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_behind(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_behind(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_in_front_of(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_in_front_of(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_inside(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_inside(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_on(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_on(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_opposite(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_opposite(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_outside(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_outside(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-encloses(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), -encloses(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_over(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_over(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
is_under(O, Y, TS+1) :- event_object(X, O), event_destination(X, D), is_under(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-location(O, L, TS+1) :- event_object(X, O), location(O, L, TS), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_near(O, Y, TS+1) :- event_object(X, O), is_near(O, Y, TS), event_destination(X, D), -is_near(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-abuts(O, Y, TS+1) :- event_object(X, O), abuts(O, Y, TS), event_destination(X, D), -abuts(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_above(O, Y, TS+1) :- event_object(X, O), is_above(O, Y, TS), event_destination(X, D), -is_above(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_below(O, Y, TS+1) :- event_object(X, O), is_below(O, Y, TS), event_destination(X, D), -is_below(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_along(O, Y, TS+1) :- event_object(X, O), is_along(O, Y, TS), event_destination(X, D), -is_along(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_at(O, Y, TS+1) :- event_object(X, O), is_at(O, Y, TS), event_destination(X, D), -is_at(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_between(O, Y, TS+1) :- event_object(X, O), is_between(O, Y, TS), event_destination(X, D), -is_between(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_behind(O, Y, TS+1) :- event_object(X, O), is_behind(O, Y, TS), event_destination(X, D), -is_behind(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_in_front_of(O, Y, TS+1) :- event_object(X, O), is_in_front_of(O, Y, TS), event_destination(X, D), -is_in_front_of(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_inside(O, Y, TS+1) :- event_object(X, O), is_inside(O, Y, TS), event_destination(X, D), -is_inside(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-encloses(O, Y, TS+1) :- event_object(X, O), encloses(O, Y, TS), event_destination(X, D), -encloses(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_on(O, Y, TS+1) :- event_object(X, O), is_on(O, Y, TS), event_destination(X, D), -is_on(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-encloses(O, Y, TS+1) :- event_object(X, O), encloses(O, Y, TS), event_destination(X, D), -encloses(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_opposite(O, Y, TS+1) :- event_object(X, O), is_opposite(O, Y, TS), event_destination(X, D), -is_opposite(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_outside(O, Y, TS+1) :- event_object(X, O), is_outside(O, Y, TS), event_destination(X, D), -is_outside(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_over(O, Y, TS+1) :- event_object(X, O), is_over(O, Y, TS), event_destination(X, D), -is_over(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

% TS is the Time Step Variable.
-is_under(O, Y, TS+1) :- event_object(X, O), is_under(O, Y, TS), event_destination(X, D), -is_under(D, Y, TS), instance(D, spatial_entity), occurs(X, TS), instance(X, move).

%---------------------
%-- Section: Axioms - Executability Conditions
%---------------------

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, transfer), event_donor(X, D), event_object(X, O), -possesses(D, O, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, transfer), event_object(X, O), event_recipient(X, R), location(R, A, TS), location(O, B, TS), #spatial_entity(A), #spatial_entity(B), A!=B.

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), event_object(X, O), event_origin(X, Or), instance(Or, spatial_entity), -location(O, Or, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), event_object(X, O), event_origin(X, Or), instance(Or, tangible_entity), location(Or, P, TS), -location(O, P, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), event_object(X, O), is_held(O, TS), -defined_agent(X).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), event_object(X, O), is_held(O, TS), event_agent(X, A), -held_by(O, A, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), event_object(X, O), is_restrained(O, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, move), event_path(X, P), is_blocked(P, TS).

% Executability Condition for when [X] is impossible to execute.
:- occurs(X, TS), instance(X, carry), event_object(X, O), event_agent(X, A), -held_by(O, A, TS).

%---------------------
%-- Section: Axioms - State Constraints Containing Fluent Functions
%---------------------

% State Constraint for function [location].
% TS is the Time Step Variable.
-location(X, Y, TS) :- location(X, Z, TS), #spatial_entity(Y), #spatial_entity(Z), Y!=Z.

% State Constraint for function [possesses].
% TS is the Time Step Variable.
possesses(B, A, TS) :- held_by(A, B, TS).

% State Constraint for function [possesses].
% TS is the Time Step Variable.
-possesses(B, A, TS) :- -held_by(A, B, TS).

% State Constraint for function [held_by].
% TS is the Time Step Variable.
held_by(B, A, TS) :- instance(B, tangible_entity), possesses(A, B, TS).

% State Constraint for function [held_by].
% TS is the Time Step Variable.
-held_by(B, A, TS) :- instance(B, tangible_entity), -possesses(A, B, TS).

% State Constraint for function [location].
% TS is the Time Step Variable.
location(A, P, TS) :- held_by(A, B, TS), location(B, P, TS), instance(A, tangible_entity).

% State Constraint for function [location].
% TS is the Time Step Variable.
-location(A, P, TS) :- held_by(A, B, TS), -location(B, P, TS), instance(A, tangible_entity).

% State Constraint for function [is_near].
% TS is the Time Step Variable.
is_near(X, Y, TS) :- is_near(Y, X, TS).

% State Constraint for function [is_near].
% TS is the Time Step Variable.
-is_near(X, Y, TS) :- -is_near(Y, X, TS).

% State Constraint for function [abuts].
% TS is the Time Step Variable.
abuts(X, Y, TS) :- abuts(Y, X, TS).

% State Constraint for function [abuts].
% TS is the Time Step Variable.
-abuts(X, Y, TS) :- -abuts(Y, X, TS).

% State Constraint for function [is_beside].
% TS is the Time Step Variable.
is_beside(X, Y, TS) :- is_beside(Y, X, TS).

% State Constraint for function [is_beside].
% TS is the Time Step Variable.
-is_beside(X, Y, TS) :- -is_beside(Y, X, TS).

% State Constraint for function [is_opposite].
% TS is the Time Step Variable.
is_opposite(X, Y, TS) :- is_opposite(Y, X, TS).

% State Constraint for function [is_opposite].
% TS is the Time Step Variable.
-is_opposite(X, Y, TS) :- -is_opposite(Y, X, TS).

% State Constraint for function [is_above].
% TS is the Time Step Variable.
-is_above(Y, X, TS) :- is_above(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_below].
% TS is the Time Step Variable.
-is_below(Y, X, TS) :- is_below(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_behind].
% TS is the Time Step Variable.
-is_behind(Y, X, TS) :- is_behind(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_in_front_of].
% TS is the Time Step Variable.
-is_in_front_of(Y, X, TS) :- is_in_front_of(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_inside].
% TS is the Time Step Variable.
-is_inside(Y, X, TS) :- is_inside(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_over].
% TS is the Time Step Variable.
-is_over(Y, X, TS) :- is_over(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_under].
% TS is the Time Step Variable.
-is_under(Y, X, TS) :- is_under(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [is_on].
% TS is the Time Step Variable.
-is_on(Y, X, TS) :- is_on(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

% State Constraint for function [encloses].
% TS is the Time Step Variable.
-encloses(Y, X, TS) :- encloses(X, Y, TS), #spatial_entity(X), #spatial_entity(Y), X!=Y.

%---------------------
%-- Section: Axioms - Fluent Function Definitions
%---------------------

% There are no rules in this section.

%---------------------
%-- Section: History - Gamma - Action Occurrences : happened(action, timestep).
%---------------------

happened(e1, 0).

happened(e2, 1).

happened(e3, 2).

happened(e4, 3).

happened(e5, 4).

happened(e6, 5).

%---------------------
%-- Section: History - Omega - Action Occurrences : occurrs(action, timestep) :- happened(action, timestep).
%---------------------

% History Translation to create occurrences of actions that happened.
occurs(e1, 0) :- happened(e1, 0).

% History Translation to create occurrences of actions that happened.
occurs(e2, 1) :- happened(e2, 1).

% History Translation to create occurrences of actions that happened.
occurs(e3, 2) :- happened(e3, 2).

% History Translation to create occurrences of actions that happened.
occurs(e4, 3) :- happened(e4, 3).

% History Translation to create occurrences of actions that happened.
occurs(e5, 4) :- happened(e5, 4).

% History Translation to create occurrences of actions that happened.
occurs(e6, 5) :- happened(e6, 5).

% END OF PROGRAM
